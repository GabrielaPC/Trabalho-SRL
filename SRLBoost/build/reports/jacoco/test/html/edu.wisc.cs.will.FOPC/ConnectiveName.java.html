<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pt"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConnectiveName.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">srlboost</a> &gt; <a href="index.source.html" class="el_package">edu.wisc.cs.will.FOPC</a> &gt; <span class="el_source">ConnectiveName.java</span></div><h1>ConnectiveName.java</h1><pre class="source lang-java linenums">package edu.wisc.cs.will.FOPC;

import edu.wisc.cs.will.Utils.Utils;

import java.io.Serializable;
import java.util.Map;

/*
 * @author shavlik
 *
 *  All functions with the same name map to the same instance. 
 */
public class ConnectiveName extends AllOfFOPC implements Serializable { // If items are added here, add them to HandleFOPCstrings as well.

	// TODO(hayesall): Simplify the language by removing some of these duplicates.

    private final static String ANDalt0        = &quot;AND&quot;;
	private final static String ANDalt1        = &quot;^&quot;;
	private final static String ANDalt2        = &quot;&amp;&quot;;
	private final static String ANDalt3        = &quot;,&quot;;
	private final static String ORalt0         = &quot;OR&quot;;
	private final static String ORalt1         = &quot;v&quot;;
	private final static String ORalt2         = &quot;|&quot;;
	private final static String ORalt3         = &quot;ELSE&quot;;
	private final static String NOTalt0        = &quot;NOT&quot;;
	private final static String NOTalt1        = &quot;~&quot;;
	private final static String NOTalt2        = &quot;\\+&quot;;
	private final static String IMPLIESalt0    = &quot;=&gt;&quot;;
	private final static String IMPLIESalt1    = &quot;-&gt;&quot;;
	private final static String IMPLIESalt2    = &quot;IMPLIES&quot;;
	private final static String IMPLIESalt3    = &quot;:-&quot;; // This is what Prolog uses.  THESE NEED TO BE IN isaBackwardsIMPLIES().
	private final static String IMPLIESalt4    = &quot;:=&quot;; // And allow these two variants.
	private final static String IMPLIESalt5    = &quot;IF&quot;;
	private final static String EQUIVALENTalt0 = &quot;&lt;=&gt;&quot;;
	private final static String EQUIVALENTalt1 = &quot;&lt;-&gt;&quot;;
	private final static String EQUIVALENTalt2 = &quot;EQUIVALENT&quot;;
	private final static String SPECIAL        = &quot;THEN&quot;;
	
	private final static String LogicalAND     = &quot;LogicalAnd&quot;;
	private final static String LogicalOR      = &quot;LogicalOr&quot;;
	private final static String LogicalNOT     = &quot;LogicalNot&quot;;

<span class="fc" id="L43">    public final static ConnectiveName AND     = new ConnectiveName(ANDalt0);</span>
<span class="fc" id="L44">    final static ConnectiveName OR      = new ConnectiveName(ORalt0);</span>
<span class="fc" id="L45">    public final static ConnectiveName NOT     = new ConnectiveName(NOTalt0);</span>

	public final String name;

<span class="fc" id="L49">	ConnectiveName(String name) { // This is protected because getConnectiveName(String name) should be used instead.</span>
<span class="fc" id="L50">		this.name = name;</span>
<span class="fc" id="L51">	}</span>

	public static boolean isaAND(String str) {
<span class="pc bpc" id="L54" title="4 of 10 branches missed.">		return (   str.equalsIgnoreCase(ConnectiveName.ANDalt0) || str.equalsIgnoreCase(ConnectiveName.ANDalt1) || str.equalsIgnoreCase(ConnectiveName.ANDalt2) || str.equalsIgnoreCase(ConnectiveName.ANDalt3) || str.equalsIgnoreCase(ConnectiveName.LogicalAND));</span>
	}
	public static boolean isaOR(String str) {
<span class="pc bpc" id="L57" title="3 of 10 branches missed.">		return (   str.equalsIgnoreCase(ConnectiveName.ORalt0)  || str.equalsIgnoreCase(ConnectiveName.ORalt1)  || str.equalsIgnoreCase(ConnectiveName.ORalt2)  ||  str.equalsIgnoreCase(ConnectiveName.ORalt3) || str.equalsIgnoreCase(ConnectiveName.LogicalOR));</span>
	}
	public static boolean isaNOT(String str) {
<span class="pc bpc" id="L60" title="3 of 8 branches missed.">		return (   str.equalsIgnoreCase(ConnectiveName.NOTalt0) || str.equalsIgnoreCase(ConnectiveName.NOTalt1) || str.equalsIgnoreCase(ConnectiveName.NOTalt2) || str.equalsIgnoreCase(ConnectiveName.LogicalNOT));</span>
	}
	static boolean isaIMPLIES(String str) {
<span class="pc bpc" id="L63" title="2 of 6 branches missed.">		return (   str.equalsIgnoreCase(ConnectiveName.IMPLIESalt0)    || str.equalsIgnoreCase(ConnectiveName.IMPLIESalt1)    || str.equalsIgnoreCase(ConnectiveName.IMPLIESalt2)</span>
<span class="pc bpc" id="L64" title="2 of 6 branches missed.">				|| str.equalsIgnoreCase(ConnectiveName.IMPLIESalt3)|| str.equalsIgnoreCase(ConnectiveName.IMPLIESalt4)    || str.equalsIgnoreCase(ConnectiveName.IMPLIESalt5));</span>
	}
	static boolean isaBackwardsIMPLIES(String str) {
<span class="pc bpc" id="L67" title="2 of 6 branches missed.">		return (   str.equalsIgnoreCase(&quot;:-&quot;) || str.equalsIgnoreCase(&quot;if&quot;) || str.equalsIgnoreCase(&quot;:=&quot;));</span>
	}
	static boolean isaEQUIVALENT(String str) {
<span class="pc bpc" id="L70" title="2 of 6 branches missed.">		return (   str.equalsIgnoreCase(ConnectiveName.EQUIVALENTalt0) || str.equalsIgnoreCase(ConnectiveName.EQUIVALENTalt1) || str.equalsIgnoreCase(ConnectiveName.EQUIVALENTalt2));</span>
	}
	private static boolean isaSPECIAL(String str) {
<span class="fc" id="L73">		return (   str.equalsIgnoreCase(ConnectiveName.SPECIAL) );</span>
	}
	
	private static boolean sameConnective(ConnectiveName a, ConnectiveName b) {
<span class="nc bnc" id="L77" title="All 2 branches missed.">        if ( a.name.equals(b.name) ) return true;</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">		if (isaAND(       a.name)) { return isaAND(       b.name); }</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">		if (isaOR(        a.name)) { return isaOR(        b.name); }</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">		if (isaNOT(       a.name)) { return isaNOT(       b.name); }</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">		if (isaIMPLIES(   a.name)) { return isaIMPLIES(   b.name); }</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">		if (isaEQUIVALENT(a.name)) { return isaEQUIVALENT(b.name); }</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">		if (isaSPECIAL(   a.name)) { return isaSPECIAL(   b.name); }</span>
<span class="nc" id="L84">		Utils.error(&quot;Unknown connectives: &lt;&lt; '&quot; + a + &quot;' &lt;&lt; and '&quot; + b + &quot;'&quot;);</span>
<span class="nc" id="L85">		return false;</span>
	}

    boolean isSameConnective(ConnectiveName that) {
<span class="nc" id="L89">        return sameConnective(this, that);</span>
    }
	
	public static boolean isaConnective(String str) {
<span class="pc bpc" id="L93" title="6 of 12 branches missed.">		return ( isaAND(str) || isaOR(str) || isaNOT(str) || isaIMPLIES(str) || isaEQUIVALENT(str) || isaSPECIAL(str) );</span>
	}

	public String toPrettyString(String newLineStarter, int precedenceOfCaller, BindingList bindingList) {
<span class="nc" id="L97">		return name;</span>
	}
	public String toString(int precedenceOfCaller, BindingList bindingList) {
<span class="nc" id="L100">		return name;</span>
	}

	public static boolean isTextualConnective(String str) {
<span class="nc bnc" id="L104" title="All 2 branches missed.">    	return  &quot;v&quot;.equalsIgnoreCase(str) ||</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">    		   &quot;if&quot;.equalsIgnoreCase(str) ||</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">    		   &quot;or&quot;.equalsIgnoreCase(str) ||</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">    		  &quot;and&quot;.equalsIgnoreCase(str) ||</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">   		     &quot;else&quot;.equalsIgnoreCase(str) ||</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">   		     &quot;then&quot;.equalsIgnoreCase(str) ||</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">   		  &quot;implies&quot;.equalsIgnoreCase(str) ||</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">   	   &quot;equivalent&quot;.equalsIgnoreCase(str);</span>
    }

	@Override
	public ConnectiveName applyTheta(Map&lt;Variable,Term&gt; bindings) {
<span class="nc" id="L116">		return this;</span>
	}
	@Override
	public int countVarOccurrencesInFOPC(Variable v) {
<span class="nc" id="L120">		return 0;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>