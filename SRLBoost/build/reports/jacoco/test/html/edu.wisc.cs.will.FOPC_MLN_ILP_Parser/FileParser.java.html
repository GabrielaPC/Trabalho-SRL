<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pt"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">srlboost</a> &gt; <a href="index.source.html" class="el_package">edu.wisc.cs.will.FOPC_MLN_ILP_Parser</a> &gt; <span class="el_source">FileParser.java</span></div><h1>FileParser.java</h1><pre class="source lang-java linenums">package edu.wisc.cs.will.FOPC_MLN_ILP_Parser;

import edu.wisc.cs.will.FOPC.*;
import edu.wisc.cs.will.FOPC.HandleFOPCstrings.VarIndicator;
import edu.wisc.cs.will.Utils.NamedReader;
import edu.wisc.cs.will.Utils.Utils;
import edu.wisc.cs.will.Utils.condor.CondorFile;
import edu.wisc.cs.will.Utils.condor.CondorFileInputStream;

import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import static edu.wisc.cs.will.Utils.MessageType.STRING_HANDLER_VARIABLE_INDICATOR;


// TODO(?): clean up so that the currentDirectory is always intelligently set (and rest after reading a file).

// Aside: search for this: Because the silly IL language has a weird way of dealing with lists, 'correct' for that here.
//        if the parser has problems with named arguments and unbracketed lists.

// Useful when printing things: tokenizer.lineno()

/*
 * Parse a file (or some other text stream) as one containing FOPC sentences as well as &quot;directives&quot; to MLN's, ILP, etc.
 * Directives include the following.   Note that many commands need to be terminated with a '.' or a ';'
 *
 *   setParam:       paramName = paramValue.        // Set this parameter to the value.  The equal sign and EOF are optional (so must all be on one line).
 *                                                  // Note that the parser does not check for valid parameter names nor values.  Later instances check this, and hence
 *                                                  // error reports might come much later.
 *
 *                                                  // Note: if a parameter - assume its name is xyz - is set it can be referred to later by @xyz.
 *                                                  //       CURRENTLY THIS ONLY WORDS FOR NUMBERS (more specifically, only via calls to processNumber) AND SINGLE TOKENS.
 *
 *
 *   bridger:        predName/numbArgs              // A special-case determinate, where the role of this predicate is to enable the addition of some other predicate(s).
 *
 *   mode:           typed_literal                  // This states the types of the arguments in this literal.
 *                   [target=pred/numbArgs]         // Types are + (an 'input' variable; MUST be present earlier in the clause), - (an 'output' variable; need not already be present in the clause), and # (a constant; need not already be present).
 *                   [max=#]                        // Also, '$' means use a variable that only appears ONCE and '^' means only use a NEW variable.  A variable can be followed by '!k' or $k' - the former means &quot;this predicate will be true for EXACTLY k possible values for this argument, where the latter is similar but for &quot;AT MOST K.&quot;
 *  			     [maxPerInputVars=#].           // Optionally [not yet implemented] can say that the above mode only applies when learning this target.  A sample is 'parentOf/2' (the literal whose predicate name is 'parentOf' and which has two arguments).
 *  			     		                        // Optionally say that typed_literal can appear in a learned clauses at most # (some integer) times.
 *  			     				                // Optionally indicate that PER SETTING to the 'input' (i.e. '+') variables, can occur at most this many times (an idea taken from Aleph).
 *              // More notes on modes:
 *				//   If a +mode, then MUST use an previously added variable of same type.
 *				//   If a $mode, then MUST use into an previously added variable that APPEARS ONLY ONCE EARLIER IN THE CLAUSE.
 *				//   If a -mode, then CAN  use an previously added variable of same type.
 *				//   If a ^mode, then treat SAME as '-' but ONLY create a new variable (ie, do NOT use other new variables of this type created for this literal)
 *				//   If a #mode, then use one of the selected positive SEEDs and find a constant of that type.  TODO - use ANY seed?  maybe the negatives offer some good values?
 *				//   If a &amp;#64;mode (at sign), then use the SPECIFIC value given (should be a constant and not a variable).
 *				//   If a &amp;mode, then combine '-' and '#'.
 *				//   If a :mode, then combine '+' and '#'.  TODO - allow MULTIPLE CHARACTERS (eg, any pair)!
 *
 *   queryPred:      predName/numbArgs.             // Used for MLNs.  The EOL ('.' or ';') is optional.
 *
 *   range:          type = {value1, ..., valueN}.  // Specify the possible values for this type.  The outer braces are optional. The shorthand &quot;...&quot; can be used for integer-valued ranges.
 *
 *   usePrologVariables:   true/false/yes/no/1/0.   // These determine whether or not lower case is a variable (standard logic) or a constant (Prolog).
 *   useStdLogicVariables:   ditto                  // These can be reset in the middle of files, and the instances created will be correct, but text files produced are likely to be inconsistent (TODO: each variable and constant needs to record its case at time of creation?  Tricky, though since 'john' and 'John' might map to the same constant.)
 *   useStdLogicNotation:             ditto
 *   usePrologNotation:               ditto
 *
 *   The following all take predicateName/arity (and an optional EOL ['.' or ';']).
 *
 *      okIfUnknown:                                // It is OK if during theorem proving this predicate is undefined.  Helps catch typos.  If numberArgs='#' then applies to all versions of predName.  The EOL ('.' or ';') is optional.
 *
 * Everything else is interpreted as an FOPC sentence (using the strings &quot;ForAll&quot; and &quot;ThereExists&quot; [&quot;Exists&quot; is also OK, but &quot;All&quot; is NOT since it is a built-in Prolog predicate] and
 * the standard logical connectives of {'and', 'or', '^', '&amp;', 'v', '-&gt;', ':-', etc.).  FOPC sentences can be weighted using one of the following:
 *
 * 		weight = double  FOPC.
 *      wgt    = double  FOPC.
 *      weight(double)   FOPC.
 *      wgt(double)      FOPC.
 *
 *   Can also use this to mark examples that are not binary valued.  NOTE: this is stored in the 'weight' field and so cannot currently have weighted examples with non-Boolean output values.
 *      output = double  FOPC.
 *   All other variants of the above, where 'output' replaces 'weight' or 'out' replaces 'wgt' are acceptable.
 *   Can also do this (ie, 'regressionExample' is a special predicate name):
 * 		regressionExample(FOPC, double).  // TODO - also allow:  weightedExample(FOPC, double)?
 *   Related to this, one can also do annotatedExample(FOPC, annotationString).  See LearnOneClause.processReadExample.
 *
 * where 'double' is some real number (integers are OK). In all of these cases a comma can optionally separate the weight specification and the FOPC sentence.
 *
 * Can also add annotation to examples
 *
 * Also a &quot;bare&quot; double that starts a sentence and is NOT followed by an in-fix operator is interpreted as a weight on the following FOPC sentence.
 *
 * Notes: The term EOL in this file is used as shorthand to mean the GRAMMATICAL end of a statement, rather than the end of a line in a file.
 *        Case doesn't matter, except when distinguishing between variables and constants.   For predicate and function names, the first version encountered will be the one used, e.g., if &quot;P&quot; is encountered first, then later cases of &quot;p&quot; will become &quot;P&quot; as well.
 *
 * TODO  handle \+ w/o parens
 *
 *
 */
public class FileParser {

	// TODO(hayesall): Deprecate quotes in the language.
	public static final boolean allowSingleQuotes = false;

	public final HandleFOPCstrings  stringHandler;
	private StreamTokenizerJWS tokenizer;
<span class="fc" id="L103">	private String             directoryName      = null;</span>
<span class="fc" id="L104">	private String             prefix             = null;</span>
<span class="fc" id="L105">	private String             fileName           = null;</span>

<span class="fc" id="L107">	public FileParser(HandleFOPCstrings stringHandler) {</span>
<span class="fc" id="L108">		this.stringHandler = stringHandler;</span>
<span class="fc" id="L109">	}</span>

	// Return what seems to be the working directory for the current task.
	public void setDirectoryName(String name) {
<span class="fc" id="L113">		checkDirectoryName(name);</span>
<span class="fc" id="L114">	}</span>
	public String getDirectoryName() {
<span class="fc" id="L116">		return directoryName;</span>
	}
	public void setPrefix(String name) {
<span class="fc" id="L119">		prefix = name;</span>
<span class="fc" id="L120">	}</span>
	public String getPrefix() {
<span class="fc" id="L122">		return prefix;</span>
	}

	// This does not allow any non-literals in the file (other than comments).
	// However it DOES allow a literal to NOT have a trailing '.' or ';' (some programs output their results in such a notation).
	public List&lt;Literal&gt; readLiteralsInPureFile(String fNameRaw) {
<span class="nc" id="L128">		String  fName          = Utils.replaceWildCardsAndCheckForExistingGZip(fNameRaw);</span>

<span class="nc" id="L130">		List&lt;Literal&gt; results = new ArrayList&lt;&gt;(4);</span>
		try {
<span class="nc" id="L132">			File   file               = (getFileWithPossibleExtension(fName));</span>
<span class="nc" id="L133">			String newDirectoryName   = file.getParent();</span>
<span class="nc" id="L134">			String hold_directoryName = directoryName;</span>
<span class="nc" id="L135">			checkDirectoryName(newDirectoryName);</span>
<span class="nc" id="L136">			this.fileName = fName; // Used to report errors.</span>
<span class="nc" id="L137">			InputStream  inStream = new CondorFileInputStream(file);</span>

<span class="nc" id="L139">			tokenizer = new StreamTokenizerJWS(new InputStreamReader(inStream)); // Don't need to do more than 2-3 push backs, so don't need a big buffer.</span>
<span class="nc" id="L140">			initTokenizer(tokenizer);</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">			while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) {</span>
<span class="nc" id="L142">				tokenizer.pushBack();</span>
<span class="nc" id="L143">				Literal lit = processLiteral();</span>
<span class="nc" id="L144">				results.add(lit);</span>
<span class="nc" id="L145">				peekEOL(); // Suck up an optional EOL.</span>
<span class="nc" id="L146">			}			</span>
<span class="nc" id="L147">			inStream.close();</span>
<span class="nc" id="L148">			checkDirectoryName(hold_directoryName);</span>
		}
<span class="nc" id="L150">		catch (FileNotFoundException e) {</span>
<span class="nc" id="L151">			Utils.reportStackTrace(e);</span>
<span class="nc" id="L152">			Utils.error(&quot;Unable to successfully read this file: &quot; + fName);</span>
		}
<span class="nc" id="L154">		catch (Exception e) {</span>
<span class="nc" id="L155">			Utils.reportStackTrace(e);</span>
<span class="nc" id="L156">			Utils.error(&quot;Unable to successfully parse this file: &quot; + fileName + &quot;.\n  Have read &quot; + Utils.comma(results) + &quot; literals.\nNOTE THIS METHOD DOES NOT HANDLE PARSER INSTRUCTIONS!\nError message: &quot; + e.getMessage());</span>
<span class="nc" id="L157">		}</span>
<span class="nc" id="L158">		return results;</span>
	}

	public List&lt;Sentence&gt; readFOPCfile(String fName) {
<span class="fc" id="L162">		return readFOPCfile(fName, false);</span>
	}

	private void checkDirectoryName(String newDirectoryName) {
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">		if (newDirectoryName == null) {</span>
		} // If this is from a reset of a 'hold' of a directory name, don't reset back to null.
<span class="fc bfc" id="L168" title="All 2 branches covered.">		else if (directoryName == null) {</span>
<span class="fc" id="L169">			directoryName = newDirectoryName;</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">		} else if (!directoryName.equals(newDirectoryName)) {</span>
<span class="fc" id="L171">			directoryName = newDirectoryName;</span>
		}
<span class="fc" id="L173">	}</span>

	private List&lt;Sentence&gt; readFOPCfile(String fNameRaw, boolean okIfNoSuchFile) {
<span class="fc" id="L176">		String fName = Utils.replaceWildCardsAndCheckForExistingGZip(fNameRaw);</span>
		try {
<span class="fc" id="L178">			File   file               = (getFileWithPossibleExtension(fName));</span>
<span class="fc" id="L179">			String newDirectoryName   = file.getParent();</span>
<span class="fc" id="L180">			String hold_directoryName = directoryName;</span>
<span class="fc" id="L181">			checkDirectoryName(newDirectoryName);</span>
<span class="fc" id="L182">			this.fileName = fName; // Used to report errors.</span>
<span class="fc" id="L183">			InputStream  inStream = new CondorFileInputStream(file);</span>
<span class="fc" id="L184">			List&lt;Sentence&gt; result = readFOPCstream(file, inStream);</span>
<span class="fc" id="L185">			inStream.close();</span>
<span class="fc" id="L186">			checkDirectoryName(hold_directoryName);</span>

<span class="fc" id="L188">			return result;</span>
		}
<span class="nc" id="L190">		catch (FileNotFoundException e) {</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">			if (okIfNoSuchFile) { return null; }</span>
<span class="nc" id="L192">			Utils.reportStackTrace(e); </span>
<span class="nc" id="L193">			Utils.error(&quot;Unable to successfully read this file:\n  &quot; + fName + &quot;\n Error message: &quot; + e.getMessage());</span>
		}
<span class="nc" id="L195">		catch (Exception e) {</span>
<span class="nc" id="L196">			Utils.reportStackTrace(e);</span>
<span class="nc" id="L197">			Utils.error(&quot;Unable to successfully parse this file: &quot; + fileName + &quot;.  Error message: &quot; + e.getMessage());</span>
<span class="nc" id="L198">		}</span>
<span class="nc" id="L199">		return null;</span>
	}
	
	// If a file exists, add the default Utils.defaultFileExtensionWithPeriod extension.
	private File getFileWithPossibleExtension(String fileNameRaw) throws IOException {
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">		if (fileNameRaw == null) {</span>
<span class="nc" id="L205">			Utils.error(&quot;Should not call with a NULL file name.&quot;);</span>
		}
<span class="fc" id="L207">		String fileName = Objects.requireNonNull(fileNameRaw).trim();</span>
<span class="fc" id="L208">		File f = new CondorFile(fileName);</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">		if (!f.exists()) {</span>
<span class="nc" id="L210">			f = new CondorFile(fileName + Utils.defaultFileExtensionWithPeriod);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">			if (!f.exists()) {</span>
<span class="nc" id="L212">				f = new CondorFile(fileName + &quot;.bk&quot;); // Try another built-in file name.</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">				if (!f.exists()) {</span>
<span class="nc" id="L214">					f = new CondorFile(fileName + &quot;.mln&quot;); // Try yet another built-in file name.</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">					if (!f.exists()) {</span>
<span class="nc" id="L216">						f = new CondorFile(fileName + &quot;.db&quot;); // Try yet another built-in file name.</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">						if (!f.exists()) {</span>
<span class="nc" id="L218">							f = new CondorFile(fileName + &quot;.fopcLibrary&quot;); // Try yet another built-in file name.</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">							if (!f.exists()) {</span>
<span class="nc" id="L220">								throw new FileNotFoundException();</span>
							}
						}
					}
				}
			}
		}
<span class="fc" id="L227">		return f;</span>
	}

	/*
	 * A variant of readFOPCfile(String fileName) where an input stream
	 * instead of a file name is provided.
	 * @return A list of sentences, the result of parsing the given file.
	 */
	private List&lt;Sentence&gt; readFOPCstream(File file, InputStream inStream) throws ParsingException {

        // This is a big hack to pass around the name with stream.
        // There are better ways to do this, but not at this point in time.
        Reader r;
<span class="fc" id="L240">		r = new InputStreamReader(inStream);</span>
<span class="fc" id="L241">		return readFOPCreader(file, r);</span>
	}

	/*
	 * A variant of readFOPCfile(String fileName) where a string instead of
	 * a file name is provided.
	 */
	public List&lt;Sentence&gt; readFOPCstream(String string) {
		try {
<span class="nc" id="L250">			return readFOPCreader(new StringReader(string), null); // Fine that there is no directory here, since reading a string.</span>
		}
<span class="nc" id="L252">		catch (Exception e) {</span>
<span class="nc" id="L253">			Utils.reportStackTrace(e);</span>
<span class="nc bnc" id="L254" title="All 4 branches missed.">			Utils.error(&quot;Error parsing: '&quot; + (string != null &amp;&amp; string.length() &gt; 1500 ? string.substring(0, 1500) + &quot; ...&quot; : string) + &quot;'.&quot;); return null;</span>
		}
	}

	public List&lt;Sentence&gt; readFOPCreader(Reader inStream, String newDirectoryName) {
<span class="fc" id="L259">		String hold_directoryName = directoryName;</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">		if (newDirectoryName != null) { checkDirectoryName(newDirectoryName); }</span>
<span class="fc" id="L261">		List&lt;Sentence&gt; results = readFOPCreader(null, inStream);</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">		if (newDirectoryName != null) { checkDirectoryName(hold_directoryName); }</span>
<span class="fc" id="L263">		return results;</span>
	}

	private void initTokenizer(StreamTokenizerJWS theTokenizer) {
<span class="fc" id="L267">		theTokenizer.resetSyntax();                // Clear everything so we can reset to what we want.</span>
<span class="fc" id="L268">		theTokenizer.ordinaryChar('/');</span>
<span class="fc" id="L269">		theTokenizer.slashSlashComments();     // The string &quot;//&quot; is interpreted as a &quot;comment from here to end of line.&quot;</span>
<span class="fc" id="L270">		theTokenizer.slashStarComments();     // The string &quot;/* starts a comments that ends at &quot;*/&quot;.</span>
<span class="fc" id="L271">		theTokenizer.commentChar('%');             // Also used YAP Prolog's character for &quot;comment from here to end of line.&quot;</span>
<span class="fc" id="L272">		theTokenizer.lowerCaseMode();         // Do NOT convert everything to lower case (case differentiates variables from constants, plus we want to print things out using the case users provided).</span>
<span class="fc" id="L273">		theTokenizer.eolIsSignificant();      // EOL is NOT significant.  Instead need a ' or a ';' to indicate EOL.</span>
<span class="fc" id="L274">		theTokenizer.quoteChar('&quot;');               // Allow quoted tokens.  Quoted tokens are always constants, regardless of the case of their first letter.</span>
<span class="fc" id="L275">		theTokenizer.quoteChar('\'');</span>
<span class="fc" id="L276">		theTokenizer.whitespaceChars(' ', ' ');    // Specify the white-space characters.</span>
<span class="fc" id="L277">		theTokenizer.whitespaceChars('\n', '\n');	//   Newline (aka, line feed).</span>
<span class="fc" id="L278">		theTokenizer.whitespaceChars('\r', '\r');	//   Carriage return.</span>
<span class="fc" id="L279">		theTokenizer.whitespaceChars('\t', '\t');	//   Tab.</span>
<span class="fc" id="L280">		theTokenizer.wordChars('A', 'Z');          // The legal characters in tokens.  Ideally should not start with a number, but no big deal.</span>
<span class="fc" id="L281">        theTokenizer.wordChars(192, 255);          // Mark (some) accented characters as word characters.</span>
<span class="fc" id="L282">		theTokenizer.wordChars('a', 'z');</span>
<span class="fc" id="L283">		theTokenizer.wordChars('\u00AA', '\u00FF'); // THIS IS DONE BOTH HERE AND IN StringConstant (though not harmful - just adds more quote marks than are necessary, when only done in one place, some problems arose).</span>
<span class="fc" id="L284">		theTokenizer.wordChars('0', '9');</span>
<span class="fc" id="L285">		theTokenizer.wordChars('_', '_');</span>
<span class="fc" id="L286">		theTokenizer.wordChars('?', '?');</span>
<span class="fc" id="L287">	}</span>

	/*
	 * A variant of readFOPCfile(String fileName) where a 'reader' instead
	 * of a file name is provided.
	 */
	private List&lt;Sentence&gt; readFOPCreader(File file, Reader inStream) {
<span class="pc bpc" id="L294" title="1 of 4 branches missed.">		if (file == null &amp;&amp; inStream == null) { return null; }</span>

<span class="fc" id="L296">		VarIndicator holdVarIndicator = stringHandler.getVariableIndicatorNoSideEffects(); // Be sure to pop back to current setting after reading.</span>
<span class="fc" id="L297">		String fileNameForErrorReporting  = &quot;stream&quot;;</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">        if ( file != null ) {</span>
<span class="fc" id="L299">            fileNameForErrorReporting =file.getParent();</span>
        }
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        else if ( inStream instanceof NamedReader ) {</span>
<span class="fc" id="L302">            fileNameForErrorReporting = inStream.toString();</span>
        }

<span class="fc" id="L305">		String hold_directoryName = directoryName;</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">		String parent = (file == null ? null : file.getParent());</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">		if (file != null) {	checkDirectoryName(parent);	}</span>

<span class="fc" id="L309">		List&lt;Sentence&gt; listOfSentencesReadOrCreated = new ArrayList&lt;&gt;(8);</span>
<span class="fc" id="L310">		tokenizer = new StreamTokenizerJWS(inStream); // Don't need to do more than 2-3 push backs, so don't need a big buffer.</span>
<span class="fc" id="L311">		initTokenizer(tokenizer);</span>
		
		
		// Note: the following should be &quot;stand-alone words&quot;:  '(', ')', ',', ', ';'. '[', ']'
		int tokenRead;
		Sentence nextSentence;

		try {
<span class="fc" id="L319">			tokenRead = tokenizer.nextToken();</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">			while (tokenRead != StreamTokenizer.TT_EOF) {  // TODO discard this test code below</span>

<span class="fc" id="L322">				nextSentence = null;</span>
				// Use this very carefully!
				// If true, will avoid copying sentences as recursive calls, due to imports, return.

<span class="pc bpc" id="L326" title="3 of 6 branches missed.">				switch (tokenRead) {</span>
					case StreamTokenizer.TT_WORD:
<span class="fc" id="L328">						String currentWord = tokenizer.sval();</span>
<span class="fc" id="L329">						boolean colonNext = checkAndConsume(':'); // If the next character is a colon, it will be &quot;sucked up&quot; and 'true' returned.  Otherwise it will be puhsed back and 'false' returned.</span>
<span class="fc bfc" id="L330" title="All 4 branches covered.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;setParam&quot;))       { processSetParameter(); break; }</span>
<span class="pc bpc" id="L331" title="1 of 4 branches missed.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;setParameter&quot;))   { throw new ParsingException(&quot;setParameter no longer supported&quot;); }</span>
<span class="fc bfc" id="L332" title="All 4 branches covered.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;mode&quot;))           { processMode(listOfSentencesReadOrCreated); break; }</span>
<span class="pc bpc" id="L333" title="1 of 4 branches missed.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;numericFunctionAsPred&quot;))           { throw new ParsingException(&quot;numericFunctionAsPred no longer supported&quot;); }</span>
<span class="fc bfc" id="L334" title="All 4 branches covered.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;bridger&quot;))        { processBridger();     break; }</span>
<span class="pc bpc" id="L335" title="1 of 4 branches missed.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;temporary&quot;))      { throw new ParsingException(&quot;temporary no longer supported&quot;); }</span>
<span class="pc bpc" id="L336" title="1 of 4 branches missed.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;inline&quot;))         { throw new ParsingException(&quot;inline no longer supported&quot;); }</span>
<span class="pc bpc" id="L337" title="1 of 4 branches missed.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;relevant&quot;))       { throw new ParsingException(&quot;relevant no longer supported&quot;); }</span>
<span class="pc bpc" id="L338" title="1 of 4 branches missed.">                        if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;nonOperational&quot;)) { throw new ParsingException(&quot;nonOperational no longer supported&quot;); }</span>
<span class="pc bpc" id="L339" title="1 of 4 branches missed.">                        if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;relevantLiteral&quot;)) { throw new ParsingException(&quot;relevantLiteral no longer supported&quot;); }</span>
<span class="pc bpc" id="L340" title="1 of 4 branches missed.">                        if ( colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;alias&quot;)) { throw new ParsingException(&quot;alias no longer supported&quot;); }</span>
<span class="pc bpc" id="L341" title="1 of 4 branches missed.">                        if ( colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;containsCallable&quot;))  { throw new ParsingException(&quot;containsCallable no longer supported&quot;); }</span>
<span class="pc bpc" id="L342" title="1 of 4 branches missed.">                        if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;supportLiteral&quot;))      { throw new ParsingException(&quot;supportLiteral no longer supported&quot;); }</span>
<span class="pc bpc" id="L343" title="1 of 4 branches missed.">                        if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;supportingPredicate&quot;)) { throw new ParsingException(&quot;supportingPredicate no longer supported&quot;);}</span>
<span class="pc bpc" id="L344" title="1 of 4 branches missed.">                        if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;supportPredicate&quot;))    { throw new ParsingException(&quot;supportPredicate no longer supported&quot;); }</span>
<span class="pc bpc" id="L345" title="1 of 4 branches missed.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;cost&quot;))                { throw new ParsingException(&quot;cost no longer supported&quot;); }</span>
<span class="pc bpc" id="L346" title="1 of 4 branches missed.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;precompute&quot;))          { throw new ParsingException(&quot;precompute no longer supported&quot;); }</span>
<span class="pc bpc" id="L347" title="1 of 4 branches missed.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;prune&quot;))          { throw new ParsingException(&quot;prune no longer supported&quot;); }</span>
<span class="pc bpc" id="L348" title="1 of 4 branches missed.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;pruneTrue&quot;))      { throw new ParsingException(&quot;pruneTrue no longer supported&quot;); }</span>
<span class="pc bpc" id="L349" title="1 of 4 branches missed.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;pruneFalse&quot;))     { throw new ParsingException(&quot;pruneFalse no longer supported&quot;); }</span>
<span class="pc bpc" id="L350" title="1 of 4 branches missed.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;isaInterval&quot;))    { throw new ParsingException(&quot;isaInterval no longer supported&quot;); }</span>
<span class="fc bfc" id="L351" title="All 4 branches covered.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;range&quot;))          { processTypeRange(  ); break; }</span>
<span class="fc bfc" id="L352" title="All 4 branches covered.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;queryPred&quot;))      { processQueryPred(  ); break; }</span>
<span class="fc bfc" id="L353" title="All 4 branches covered.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;okIfUnknown&quot;))                    { processDirective(currentWord);  break; }</span>

<span class="pc bpc" id="L355" title="1 of 4 branches missed.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;useStdLogicVariables&quot;)) {</span>
<span class="nc" id="L356">							throw new ParsingException(&quot;useStdLogicVariables is deprecated.&quot;);</span>
						}
<span class="pc bpc" id="L358" title="1 of 4 branches missed.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;useStdLogicNotation&quot;)) {</span>
<span class="nc" id="L359">							throw new ParsingException(&quot;useStdLogicNotation is deprecated.&quot;);</span>
						}
<span class="pc bpc" id="L361" title="1 of 4 branches missed.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;usePrologVariables&quot;)) {</span>
<span class="fc" id="L362">							processCaseForVariables();</span>
<span class="fc" id="L363">							break;</span>
						}
<span class="pc bpc" id="L365" title="3 of 4 branches missed.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;usePrologNotation&quot;)) {</span>
<span class="nc" id="L366">							throw new ParsingException(&quot;usePrologNotation&quot;);</span>
						}
<span class="pc bpc" id="L368" title="3 of 4 branches missed.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;import&quot;))      { throw new ParsingException(&quot;import no longer supported&quot;); }</span>
<span class="pc bpc" id="L369" title="3 of 4 branches missed.">						if (colonNext &amp;&amp; currentWord.equalsIgnoreCase(&quot;importLibrary&quot;))      { throw new ParsingException(&quot;importLibrary no longer supported&quot;); }</span>

<span class="pc bpc" id="L371" title="1 of 2 branches missed.">						if (colonNext) { tokenizer.pushBack(); } // Need to push the colon back if it wasn't part of a special instruction.  It can also appear in modes of terms.</span>

<span class="pc bpc" id="L373" title="2 of 4 branches missed.">						if (currentWord.equalsIgnoreCase(&quot;weight&quot;) || currentWord.equalsIgnoreCase(&quot;wgt&quot;)) {</span>
<span class="nc" id="L374">							throw new ParsingException(&quot;weight no longer supported&quot;);</span>
						}
<span class="pc bpc" id="L376" title="4 of 6 branches missed.">						if (!ConnectiveName.isaNOT(currentWord) &amp;&amp; ConnectiveName.isaConnective(currentWord) &amp;&amp; !ConnectiveName.isTextualConnective(currentWord)) { // NOT's handled by processFOPC_sentence.</span>
<span class="nc" id="L377">							throw new ParsingException(&quot;Deprecated&quot;);</span>
						}
						// The default is to read an FOPC sentence.
<span class="fc" id="L380">						tokenizer.pushBack();</span>
<span class="fc" id="L381">						nextSentence =                                                  processFOPC_sentence(0);</span>
<span class="fc" id="L382">						break;</span>
					case StreamTokenizer.TT_NUMBER:
<span class="nc" id="L384">						throw new ParsingException(&quot;Should not happen in the parser:  Read this NUMBER: &quot; + tokenizer.nval());  // See comment above as to why this won't be reached.</span>
					case '\\':  // Could be starting '\+'
					case '~':
					case '(':
					case '{':
					case '[':
					case '!':
					case '+': // Could have something like '+5 &lt; y'
					case '-': // Or, more likely, '-5 &lt; y'   Could also be a &quot;bare&quot; weight.
<span class="fc" id="L393">						tokenizer.pushBack(); // The FOPC reader can handle these characters.</span>
<span class="fc" id="L394">						nextSentence = processFOPC_sentence(0);</span>
<span class="fc" id="L395">						break;</span>
					case '.': // An empty sentence is OK, plus reading an FOPC sentence never sucks up the closing EOL.
					case ';':
<span class="fc" id="L398">						break;</span>
					case StreamTokenizer.TT_EOL:
<span class="nc" id="L400">						throw new ParsingException(&quot;Should not read EOL's here.&quot;); // EOL is in the &quot;traditional&quot; sense here (e.g., '\n').</span>
					default:
<span class="nc bnc" id="L402" title="All 2 branches missed.">						if (tokenRead == '/') {</span>
<span class="nc" id="L403">							Utils.println(&quot;If a file ends with '*/' add a space after the '/' to overcome an apparent bug with StringTokenizer's handling of comments.&quot;);</span>
						}
<span class="nc" id="L405">						throw new ParsingException(&quot;Read this *unexpected* character: '&quot; + (char)tokenRead + &quot;'.&quot;); // TODO - hit this once when the last character was the '/' in a closing quote (i.e., '*/').  Added a space afterwards and all worked fine.</span>
				}
<span class="fc bfc" id="L407" title="All 2 branches covered.">				if (nextSentence != null) {</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">					if (nextSentence.containsTermAsSentence()) {</span>
<span class="nc" id="L409">						throw new ParsingException(&quot;This is not a valid FOPC sentence: '&quot; + nextSentence + &quot;.'  It contains a logical term where a logical sentence should appear.&quot;);</span>
					}
<span class="fc" id="L411">					Sentence finalSentence = nextSentence.wrapFreeVariables(); // Add any implicit ForAll.</span>
<span class="fc" id="L412">					listOfSentencesReadOrCreated.add(finalSentence);</span>
				}
<span class="fc" id="L414">				stringHandler.resetAllVariables(); // Clear cache of variables, since old ones (if any) now out of scope.</span>
<span class="fc" id="L415">				tokenRead = tokenizer.nextToken();</span>
			}
<span class="nc" id="L417">		} catch (Exception e) {</span>
<span class="nc" id="L418">			Utils.reportStackTrace(e);</span>
<span class="nc" id="L419">			Utils.error(&quot;Unable to successfully parse this file: &quot; + fileNameForErrorReporting + &quot;.\nError message: &quot; + e.getMessage());</span>
<span class="fc" id="L420">		}</span>
<span class="fc" id="L421">		checkDirectoryName(hold_directoryName);</span>

<span class="fc bfc" id="L423" title="All 2 branches covered.">		if (holdVarIndicator != null) { // If previously set, revert to that setting.</span>
<span class="fc" id="L424">			stringHandler.setVariableIndicator(holdVarIndicator);</span>
		} else {
<span class="fc" id="L426">			Utils.warning(STRING_HANDLER_VARIABLE_INDICATOR, &quot;% Since this is the first setting of the notation for variables, will keep:\n%   variableIndicator = &quot; + stringHandler.getVariableIndicator(), 1);</span>
		}

<span class="fc" id="L429">		return listOfSentencesReadOrCreated;</span>
	}

	public Clause parseDefiniteClause(String definiteClause) throws ParsingException {

<span class="nc" id="L434">        Clause result = null;</span>

        List&lt;Sentence&gt; sentences;
        
<span class="nc bnc" id="L438" title="All 2 branches missed.">        if (!definiteClause.endsWith(&quot;.&quot;)) {</span>
<span class="nc" id="L439">            definiteClause = definiteClause + &quot;.&quot;;</span>
        }

<span class="nc" id="L442">        sentences = readFOPCstream(definiteClause);</span>

<span class="nc bnc" id="L444" title="All 2 branches missed.">        if ( sentences == null ) {</span>
<span class="nc" id="L445">            throw new ParsingException(&quot;parseDefiniteClause generated multiple clauses from: '&quot; + definiteClause + &quot;'.&quot;);</span>
        }

<span class="nc bnc" id="L448" title="All 2 branches missed.">        if ( sentences.size() &gt; 1 ) {</span>
<span class="nc" id="L449">            throw new ParsingException(&quot;parseDefiniteClause generated multiple clauses from: '&quot; + definiteClause + &quot;'.&quot;);</span>
        }

<span class="nc bnc" id="L452" title="All 2 branches missed.">        if ( sentences.size() == 1) {</span>
<span class="nc" id="L453">            Sentence s = sentences.get(0);</span>

<span class="nc" id="L455">            List&lt;Clause&gt; clauses = s.convertToClausalForm();</span>

<span class="nc bnc" id="L457" title="All 2 branches missed.">            if ( clauses.size() &gt; 1 ) {</span>
<span class="nc" id="L458">                throw new ParsingException(&quot;parseDefiniteClause generated multiple clauses from: '&quot; + definiteClause + &quot;'.&quot;);</span>
            }

<span class="nc bnc" id="L461" title="All 2 branches missed.">            if ( clauses.size() == 1 ) {</span>
<span class="nc" id="L462">                result = clauses.get(0);</span>
            }
        }

<span class="nc" id="L466">        return result;</span>
    }

	/*
	 * Allow specification of notation for logical variables.  See comments about &quot;useStdLogicVariables&quot; and &quot;usePrologVariables&quot; above.
	 */
	private void processCaseForVariables() throws ParsingException, IOException {
<span class="fc" id="L473">		int nextToken = tokenizer.nextToken();</span>

<span class="pc bpc" id="L475" title="1 of 2 branches missed.">		if (nextToken != StreamTokenizer.TT_WORD) {</span>
<span class="nc" id="L476">			throw new ParsingException(&quot;Expecting a token after useStdLogicVariables/usePrologVariables&quot;);</span>
		}
<span class="pc bpc" id="L478" title="5 of 6 branches missed.">		if (tokenizer.sval().equalsIgnoreCase(&quot;true&quot;) || tokenizer.sval().equalsIgnoreCase(&quot;yes&quot;) || tokenizer.sval().equalsIgnoreCase(&quot;1&quot;)) {</span>
<span class="fc" id="L479">			stringHandler.usePrologNotation();</span>
		}
		else {
<span class="nc" id="L482">			stringHandler.useStdLogicNotation();</span>
		}
<span class="fc" id="L484">		peekEOL();</span>
<span class="fc" id="L485">	}</span>

	private Sentence convertAccumulatorToFOPC(List&lt;AllOfFOPC&gt; accumulator) throws ParsingException {
<span class="pc bpc" id="L488" title="2 of 4 branches missed.">		if (accumulator == null || accumulator.isEmpty()) {  // OK to have the empty sentence.</span>
<span class="nc" id="L489">			return null;</span>
		}
<span class="fc bfc" id="L491" title="All 2 branches covered.">		while (accumulator.size() &gt; 1) {</span>
			//  First find the lowest-precedence operator.
<span class="fc" id="L493">			int lowestPrecedence  = Integer.MAX_VALUE;</span>
<span class="fc" id="L494">			int countOfLowestItem = -1;</span>
<span class="fc" id="L495">			int counter           =  0;</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">			for (AllOfFOPC item : accumulator) {</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">				if (item instanceof ConnectiveName) {</span>
<span class="fc" id="L498">					int precedence = stringHandler.getConnectivePrecedence((ConnectiveName) item);</span>

<span class="pc bpc" id="L500" title="1 of 2 branches missed.">					if (precedence &lt;= lowestPrecedence) {</span>
<span class="fc" id="L501">						lowestPrecedence = precedence;</span>
<span class="fc" id="L502">						countOfLowestItem = counter;</span>
					}
				}
<span class="fc" id="L505">				counter++;</span>
<span class="fc" id="L506">			}</span>
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">			if (countOfLowestItem &lt; 0) {</span>
<span class="nc" id="L508">				Utils.error(&quot;Something went wrong when grouping the items in a complex FOPC sentence: &quot; + accumulator);</span>
			}
<span class="fc" id="L510">			ConnectiveName  cName    = (ConnectiveName) accumulator.get(countOfLowestItem);</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">			if (ConnectiveName.isaNOT(cName.name)) { // If 'NOT' or '~' is the connective, need to handle it specially as an in-fix operator.</span>
<span class="nc" id="L512">				throw new ParsingException(&quot;Deprecated&quot;);</span>
			}
			else { // Next combine the lowest-precedence operator and make a sentence with it and its two neighbors.
<span class="pc bpc" id="L515" title="2 of 4 branches missed.">				if (countOfLowestItem &lt; 1 || countOfLowestItem &gt; accumulator.size() - 2) {</span>
<span class="nc" id="L516">					Utils.error(&quot;Connectives cannot be in the first or last positions: &quot; + accumulator);</span>
				}
<span class="fc" id="L518">				Sentence leftArg  = (Sentence)accumulator.get(countOfLowestItem - 1);</span>
<span class="fc" id="L519">				Sentence rightArg = (Sentence)accumulator.get(countOfLowestItem + 1);</span>
<span class="fc" id="L520">				Sentence cSent    = stringHandler.getConnectedSentence(leftArg, cName, rightArg);</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">				if (cName.name.equalsIgnoreCase(&quot;then&quot;)) {</span>
<span class="nc" id="L522">					throw new ParsingException(&quot;'then' is deprecated&quot;);</span>
				}
<span class="fc" id="L524">				accumulator.add(   countOfLowestItem + 2, cSent); // Add after the three items being combined.</span>
<span class="fc" id="L525">				accumulator.remove(countOfLowestItem + 1); // Do this in the proper order so shifting doesn't mess up counting.</span>
<span class="fc" id="L526">				accumulator.remove(countOfLowestItem);</span>
<span class="fc" id="L527">				accumulator.remove(countOfLowestItem - 1);</span>
			}
<span class="fc" id="L529">		}</span>

<span class="fc" id="L531">		return (Sentence) accumulator.get(0);</span>
	}

	private String isInfixTokenPredicate(int tokenRead) throws ParsingException {
<span class="pc bpc" id="L535" title="4 of 6 branches missed.">		switch (tokenRead) {  // If changed, check out checkForPredicateNamesThatAreCharacters (for cases where a single-char string is returned).</span>
		case '\\':
<span class="nc" id="L537">			throw new ParsingException(&quot;Deprecated&quot;);</span>
		case '=': // By itself, '=' means unify (and '==' means 'equal').
<span class="nc" id="L539">			throw new ParsingException(&quot;Deprecated&quot;);</span>
		case '&lt;':
<span class="nc" id="L541">			throw new ParsingException(&quot;Deprecated&quot;);</span>
		case '&gt;':
<span class="nc" id="L543">			throw new ParsingException(&quot;Deprecated&quot;);</span>
		case StreamTokenizer.TT_WORD:
<span class="fc" id="L545">			String tokenString = tokenizer.sval();</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">			if (tokenString.equalsIgnoreCase(&quot;is&quot;)) {</span>
<span class="nc" id="L547">				throw new ParsingException(&quot;Deprecated&quot;);</span>
			}
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">			if (tokenString.equalsIgnoreCase(&quot;mod&quot;)) {</span>
<span class="nc" id="L550">				throw new ParsingException(&quot;Deprecated&quot;);</span>
			}
<span class="fc" id="L552">			return null;</span>
		default:
<span class="fc" id="L554">			return null;</span>
		}
	}

	// TODO - clean this up
	private int checkForPredicateNamesThatAreCharacters(int tokenRead) throws ParsingException, IOException {
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">		if (!isaPossibleTermName(tokenRead)) {</span>
<span class="nc" id="L561">			throw new ParsingException(&quot;Deprecated&quot;);</span>
		}
<span class="fc" id="L563">		String seeIfPredNameUsingCharacters = getPredicateOrFunctionName(tokenRead);</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">		if (seeIfPredNameUsingCharacters != null) {</span>
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">			if (&quot;-&quot;.equals(seeIfPredNameUsingCharacters)) {</span>
<span class="nc" id="L566">				throw new ParsingException(&quot;Deprecated&quot;);</span>
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">			} else if (&quot;+&quot;.equals(seeIfPredNameUsingCharacters)) {</span>
<span class="nc" id="L568">				throw new ParsingException(&quot;Deprecated&quot;);</span>
			} else {
<span class="fc" id="L570">				tokenizer.pushBack(seeIfPredNameUsingCharacters); // Hopefully no prevToken called here ...</span>
			}
<span class="fc" id="L572">			return getNextToken();</span>
		}
<span class="nc" id="L574">		return tokenRead;</span>
	}

	/* Returns true  if the next token is tokenToEval and consume it if it is.
     *
     * If the token doesn't match tokenToEval, the token isn't consumed.
     *
     * @param tokenToEval Token to look for.
     * @return True if next token = tokenToEval.  False otherwise.
     */
    private boolean checkAndConsumeToken(String tokenToEval) throws ParsingException, IOException {
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">        if (atEOL()) {</span>
<span class="nc" id="L586">            return false;</span>
        }

<span class="fc" id="L589">		getNextToken();</span>
<span class="fc" id="L590">        String currentWord = tokenizer.reportCurrentToken();</span>

<span class="fc bfc" id="L592" title="All 2 branches covered.">        if (currentWord.equals(tokenToEval)) {</span>
<span class="fc" id="L593">            return true;</span>
        }
        else {
<span class="fc" id="L596">            tokenizer.pushBack();</span>
<span class="fc" id="L597">            return false;</span>
        }
    }

    /* Returns true if the next token is tokenToEval but does not consume it.
     *
     * @param tokenToEval Token to look for.
     * @return True if next token = tokenToEval.  False otherwise.
     */
    private boolean checkToken(String tokenToEval) throws ParsingException, IOException {
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">        if (atEOL()) {</span>
<span class="nc" id="L608">            return false;</span>
        }

<span class="fc" id="L611">		getNextToken();</span>
<span class="fc" id="L612">        String currentWord = tokenizer.reportCurrentToken();</span>
<span class="fc" id="L613">        tokenizer.pushBack();</span>

<span class="fc" id="L615">		return currentWord.equals(tokenToEval);</span>
    }

    /* Reads the next token,makes sure it is tokenToEval, and consumes it.
     *
     * @param tokenToEval Expected next token.
     * @throws ParsingException Thrown if the next token is not tokenToEval.
     */
    private void expectAndConsumeToken(String tokenToEval) throws ParsingException, IOException {
<span class="fc" id="L624">        boolean done = false;</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">        while(!done) {</span>

<span class="pc bpc" id="L627" title="1 of 2 branches missed.">			if ( atEOL()  ) throw new ParsingException(&quot;Unexpected end of file.  Expected '&quot; + tokenToEval + &quot;'.&quot; );</span>

<span class="fc" id="L629">			getNextToken();</span>
<span class="fc" id="L630">			String currentWord = tokenizer.reportCurrentToken();</span>

<span class="pc bpc" id="L632" title="1 of 2 branches missed.">			if (!tokenToEval.startsWith(currentWord)) {</span>
<span class="nc" id="L633">				throw new ParsingException(&quot;Unexpected token '&quot; + currentWord + &quot;'.  Expected '&quot; + tokenToEval + &quot;'.&quot; );</span>
			}
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">			else if ( tokenToEval.length() != currentWord.length()) {</span>
<span class="nc" id="L636">				tokenToEval = tokenToEval.substring(currentWord.length());</span>
			}
			else {
<span class="fc" id="L639">				done = true;</span>
			}
<span class="fc" id="L641">        }</span>
<span class="fc" id="L642">    }</span>

	private void processDirective(String directiveName) throws ParsingException, IOException {
		// Have already read something like 'okIfUnknown:&quot; (the colon isn't passed in).
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">		if (directiveName == null) {</span>
<span class="nc" id="L647">			throw new ParsingException(&quot;Cannot pass in directiveName=null.&quot;);</span>
		} // This is a programmer, rather than user, error.
<span class="fc" id="L649">		int tokenRead = checkForPredicateNamesThatAreCharacters(getNextToken());</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">		if (tokenRead == StreamTokenizer.TT_WORD) {</span>
<span class="fc" id="L651">			String currentWord = tokenizer.sval();</span>
<span class="fc" id="L652">			PredicateName pName = stringHandler.getPredicateName(currentWord);</span>
<span class="fc" id="L653">			tokenRead = getNextToken();</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">			if (tokenRead != '/') {</span>
<span class="nc" id="L655">				throw new ParsingException(&quot;Expecting a '/' (slash) in a '&quot; + directiveName + &quot;' specification, but got: '&quot; + reportLastItemRead() + &quot;'.&quot;);</span>
			}
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">			if (checkAndConsume('#')) {</span>
<span class="nc" id="L658">				throw new ParsingException(&quot;Deprecated.&quot;);</span>
			} else {
<span class="fc" id="L660">				int arity = readInteger();</span>
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">				if (directiveName.equalsIgnoreCase(&quot;okIfUnknown&quot;)) {</span>
<span class="fc" id="L662">					pName.setCanBeAbsent(arity);</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">				} else if (directiveName.equalsIgnoreCase(&quot;dontComplainAboutMultipleTypes&quot;)) {</span>
<span class="nc" id="L664">					pName.setDontComplainAboutMultipleTypes(arity);</span>
				} else {
					// This is a programmer, rather than user, error.
<span class="nc" id="L667">					throw new ParsingException(&quot;Cannot process directiveName=&quot; + directiveName+ &quot;.&quot;);</span>
				}
			}
<span class="fc" id="L670">			peekEOL();</span>
<span class="fc" id="L671">			return;</span>
		}
<span class="nc" id="L673">		throw new ParsingException(&quot;Expecting the name of a predicate in a '&quot; + directiveName + &quot;' but read: '&quot; + reportLastItemRead() + &quot;'.&quot;);</span>
	}

	private double processNumber(int tokenRead) throws ParsingException {
<span class="fc" id="L677">		int countOfBackupsNeeded = 0;</span>
<span class="fc" id="L678">		int negate               = 1;</span>
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">		if (tokenRead == '@') {  // A leading @ indicates the value needs to be looked up in the list of set parameters.</span>
<span class="nc" id="L680">			throw new ParsingException(&quot;Deprecated.&quot;);</span>
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">		} else if (tokenRead == '-')  { // Have a minus sign.</span>
<span class="nc" id="L682">			throw new ParsingException(&quot;Deprecated.&quot;);</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">		} else if (tokenRead == '+')  { // Allow a plus sign.</span>
<span class="nc" id="L684">			throw new ParsingException(&quot;Deprecated.&quot;);</span>
		}

<span class="pc bpc" id="L687" title="1 of 2 branches missed.">		if (tokenizer.ttype() != StreamTokenizer.TT_WORD) {</span>
<span class="nc" id="L688">			throw new ParsingException(&quot;Deprecated.&quot;);</span>
		}

<span class="fc" id="L691">		String wordRead = tokenizer.sval();</span>
<span class="fc" id="L692">		Long integerConstant = null;</span>
<span class="fc" id="L693">        char firstCharacter = wordRead.charAt(0);</span>
<span class="pc bpc" id="L694" title="1 of 4 branches missed.">        if ( firstCharacter &gt;= '0' &amp;&amp; firstCharacter &lt;= '9') {</span>
            try {  // See if the word read can be viewed as an integer.
<span class="fc" id="L696">                integerConstant = Long.valueOf(wordRead);  // Notice: due to bug mentioned above, we need to handle decimal points ourselves.</span>
				// If integer read w/o problem, then the reads above were fine.
<span class="fc bfc" id="L698" title="All 2 branches covered.">				if (checkAndConsume('.')) {</span>
<span class="fc" id="L699">                    countOfBackupsNeeded++; // For the decimal point.</span>
<span class="fc" id="L700">                    countOfBackupsNeeded++;</span>
<span class="fc" id="L701">                    int nextToken = getNextToken(); // If so, look at the next word.</span>
<span class="pc bpc" id="L702" title="1 of 2 branches missed.">                    if (nextToken != StreamTokenizer.TT_WORD) { throw new ParsingException(&quot;Period is not decimal point.&quot;); }</span>
<span class="fc" id="L703">                    String wordRead2 = tokenizer.sval();</span>
                    try {
<span class="fc" id="L705">                        String wordRead3 = &quot;&quot;;</span>
<span class="fc" id="L706">                        char lastChar  = wordRead2.charAt(wordRead2.length() - 1);</span>
<span class="fc bfc" id="L707" title="All 4 branches covered.">                        if (lastChar == 'e' || lastChar == 'E') { // If last character is 'e' or 'E' then maybe have scientific notation.</span>
<span class="fc" id="L708">                            countOfBackupsNeeded++;</span>
<span class="fc" id="L709">                            nextToken = getNextToken();</span>
<span class="pc bpc" id="L710" title="1 of 3 branches missed.">                            switch (nextToken) {</span>
                                case '+':
									// TODO(hayesall): This can *probably* be deprecated, but explicitly saying a number is positive *might* be reasonable?
<span class="nc" id="L713">                                    countOfBackupsNeeded++;</span>
<span class="nc" id="L714">                                    nextToken = getNextToken();</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">                                    if (nextToken != StreamTokenizer.TT_WORD) { tokenizer.pushBack(countOfBackupsNeeded); throw new ParsingException(&quot;Period is not decimal point.&quot;); }</span>
<span class="nc" id="L716">                                    wordRead3 = &quot;+&quot; + tokenizer.sval(); break; // Could leave out the &quot;+&quot; but leave it in since the user did ...</span>
                                case '-':
<span class="fc" id="L718">                                    countOfBackupsNeeded++;</span>
<span class="fc" id="L719">                                    nextToken = getNextToken();</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">                                    if (nextToken != StreamTokenizer.TT_WORD) { tokenizer.pushBack(countOfBackupsNeeded); throw new ParsingException(&quot;Period is not decimal point.&quot;); }</span>
<span class="fc" id="L721">                                    wordRead3 = &quot;-&quot; + tokenizer.sval(); break;</span>
<span class="fc" id="L722">                                default: throw new NumberFormatException(); // If of the form '2e3' will read all in one fell swoop, so only need to deal with '+' or '-' being &quot;token breakers.&quot;</span>
                            }
                        }
<span class="fc" id="L725">                        String doubleAsString = wordRead + &quot;.&quot; + wordRead2 + wordRead3;</span>
<span class="fc" id="L726">                        return negate * Double.parseDouble(doubleAsString);</span>
                    }
<span class="fc" id="L728">                    catch (NumberFormatException e) {</span>
<span class="fc" id="L729">                        tokenizer.pushBack(countOfBackupsNeeded); // Push back the word after the decimal point and return the decimal point.</span>
<span class="fc" id="L730">                        return negate * integerConstant; // Then simply return the integer read.</span>
                    }
                }
<span class="fc" id="L733">                return negate * integerConstant;</span>
            }
<span class="nc" id="L735">            catch (NumberFormatException e) { // If here, cannot read as an integer (nor as a double).</span>
<span class="nc" id="L736">                tokenizer.pushBack(countOfBackupsNeeded); // Return to where the processNumber() started.</span>
<span class="nc" id="L737">                return Double.NaN;</span>
            }
<span class="nc" id="L739">            catch (IOException e) { // Tried to read a '.' as a decimal point, whereas it is an EOL followed by an EOF.</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">                if (e.getMessage().startsWith(&quot;Unexpected EOF&quot;)) {</span>
<span class="nc" id="L741">                    tokenizer.pushBack(countOfBackupsNeeded); // Push back the EOF.</span>
<span class="nc" id="L742">                    return negate * integerConstant;</span>
                }
<span class="nc" id="L744">                throw new ParsingException(&quot;Unexpectedly reached an I/O exception: &quot; + e.getMessage());</span>
            }
<span class="nc" id="L746">            catch (Exception e) { // Tried to read a '.' as a decimal point, whereas it is an EOL.</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">                if (e.getMessage().startsWith(&quot;Period is not decimal point&quot;)) {</span>
<span class="nc" id="L748">                    tokenizer.pushBack(countOfBackupsNeeded); // Push back the decimal point, which is an EOL here.  Needed to read PAST the decimal point to make this decision, so need to return TWO tokens here.</span>
<span class="nc" id="L749">                    return negate * integerConstant;</span>
                }
<span class="nc" id="L751">                throw new ParsingException(&quot;Unexpected exception dealing with a period: &quot; + e.getMessage());</span>
            }
        }
<span class="fc" id="L754">		tokenizer.pushBack(countOfBackupsNeeded); // Return to where the processNumber() started.</span>
<span class="fc" id="L755">		return Double.NaN;</span>
	}

	// Read two strings and store.
	private void processSetParameter() throws ParsingException, IOException {
<span class="fc" id="L760">		int    tokenRead = getNextToken();</span>
<span class="fc" id="L761">		String parameterName   = getPossiblyQuotedString(tokenRead);</span>

<span class="fc" id="L763">		checkAndConsume('=');</span>
<span class="fc" id="L764">		tokenRead             = getNextToken();</span>
<span class="fc" id="L765">		double resultAsNumber = processNumber(tokenRead);</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">		if (Utils.isaNumber(resultAsNumber)) {</span>
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">			if (Math.floor(resultAsNumber) == resultAsNumber) { // See if really an integer.</span>
<span class="fc" id="L768">				stringHandler.recordSetParameter(parameterName, Integer.toString((int) resultAsNumber));</span>
			} else {
<span class="nc" id="L770">				stringHandler.recordSetParameter(parameterName, Double.toString(       resultAsNumber));</span>
			}
		} else {
<span class="fc" id="L773">			String parameterValue = getPossiblyQuotedString(tokenRead);</span>
<span class="fc" id="L774">			stringHandler.recordSetParameter(parameterName, parameterValue);</span>

			// Handle parser strings here.
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">			if (parameterName.equalsIgnoreCase(&quot;parsingWithNamedArguments&quot;)) {</span>
<span class="nc" id="L778">				throw new ParsingException(&quot;parsingWithNamedArguments no longer supported&quot;);</span>
<span class="pc bpc" id="L779" title="1 of 2 branches missed.">			} else if (parameterName.equalsIgnoreCase(&quot;maxWarnings&quot;)) {</span>
<span class="nc" id="L780">				throw new ParsingException(&quot;maxWarnings no longer supported&quot;);</span>
<span class="pc bpc" id="L781" title="1 of 2 branches missed.">			} else if (parameterName.equalsIgnoreCase(&quot;variablesStartWithQuestionMarks&quot;)) {</span>
<span class="nc" id="L782">				throw new ParsingException(&quot;variablesStartWithQuestionMarks no longer supported&quot;);</span>
<span class="pc bpc" id="L783" title="1 of 2 branches missed.">			} else if (parameterName.equalsIgnoreCase(&quot;stringsAreCaseSensitive&quot;)) {</span>
<span class="fc" id="L784">				stringHandler.setStringsAreCaseSensitive(Boolean.parseBoolean(parameterValue));</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">			} else if (parameterName.equals(&quot;duplicateRuleAction&quot;)) {</span>
<span class="nc" id="L786">				throw new ParsingException(&quot;duplicateRuleAction no longer supported&quot;);</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">            } else if (parameterName.equals(&quot;duplicateFactAction&quot;)) {</span>
<span class="nc" id="L788">				throw new ParsingException(&quot;duplicateFactAction no longer supported&quot;);</span>
            }
		}
<span class="fc" id="L791">		peekEOL();</span>
<span class="pc bpc" id="L792" title="2 of 4 branches missed.">		if (parameterName.contains(&quot;precompute&quot;) || parameterName.contains(&quot;import&quot;)) {</span>
<span class="nc" id="L793">			throw new ParsingException(&quot;Should not have precomputes or import statements here.&quot;);</span>
		}
<span class="fc" id="L795">	}</span>

	/*
	 * Process the specification of the range of a type, e.g. 'teenage = 13,
	 * ..., 19.' and 'size = {small, medium, large};' Braces are optional.
	 * The EOL ('.' or ';') is optional IF the braces are present. Note that
	 * DOUBLES currently cannot be types (if they were to be allowed, would
	 * need to require {}'s so the EOL use of ' could be differentiated from
	 * a decimal point.
	 */
	private void processTypeRange() throws ParsingException, IOException {  // TODO handle doubles here but only if in braces.

		// TODO(hayesall): Enforce range syntax to include '{}'

<span class="fc" id="L809">		int typeNameCode = getNextToken();</span>
<span class="pc bpc" id="L810" title="1 of 2 branches missed.">		if (typeNameCode != StreamTokenizer.TT_WORD) { Utils.error(&quot;Expecting the name of a type, but got: &quot; + reportLastItemRead() + &quot;.&quot;); }</span>
<span class="fc" id="L811">		String typeName = tokenizer.sval();</span>
<span class="fc" id="L812">		int tokenRead = getNextToken();</span>
<span class="pc bpc" id="L813" title="1 of 2 branches missed.">		if (tokenRead != '=') { Utils.error(&quot;Expecting '=' but got: &quot; + reportLastItemRead() + &quot;.&quot;); }</span>

<span class="fc" id="L815">		boolean needClosingBrace  = false;</span>

<span class="fc" id="L817">		List&lt;Constant&gt; constants = new ArrayList&lt;&gt;(4);</span>
<span class="fc" id="L818">		tokenRead = getNextToken();</span>
<span class="pc bpc" id="L819" title="1 of 2 branches missed.">		if (tokenRead == '{') { needClosingBrace = true; tokenRead = getNextToken(); }</span>

<span class="pc bpc" id="L821" title="2 of 6 branches missed.">		while (tokenRead != '.' &amp;&amp; tokenRead != ';' &amp;&amp; tokenRead != '}') {</span>
<span class="fc" id="L822">			String constantAsString = tokenizer.sval();</span>
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">			if (isAllDigits(constantAsString)) {</span>
<span class="nc" id="L824">				constants.add(stringHandler.getNumericConstant(Integer.parseInt(constantAsString)));</span>
			} else {
<span class="fc" id="L826">				constants.add(stringHandler.getStringConstant(constantAsString));</span>
			}
<span class="fc" id="L828">			checkForComma();</span>
<span class="fc" id="L829">			tokenRead = getNextToken();</span>
<span class="pc bpc" id="L830" title="1 of 2 branches missed.">			if (tokenRead == '.') { // See if this is '...'</span>
<span class="nc bnc" id="L831" title="All 4 branches missed.">				if (checkAndConsume('.') &amp;&amp; checkAndConsume('.')) {</span>
<span class="nc" id="L832">					throw new ParsingException(&quot;Using '...' is deprecated in ranges.&quot;);</span>
				}
			}
<span class="fc" id="L835">		}</span>
<span class="pc bpc" id="L836" title="1 of 2 branches missed.">		if (needClosingBrace) {</span>
<span class="pc bpc" id="L837" title="1 of 2 branches missed.">			if (tokenRead != '}') { throw new ParsingException(&quot;Since an open brace ('{') was read, expecting a closing one in the specification of a type range.&quot;); }</span>
<span class="fc" id="L838">			peekEOL(); // Suck up an optional EOL.</span>
		}

<span class="fc" id="L841">		stringHandler.recordPossibleTypes(typeName, constants);</span>
<span class="fc" id="L842">	}</span>

	/* Process a mode specification.  There needs to be an EOL at the end ('.' or ';') due to the optional arguments.
	 *  If the optional arguments are used, they can be separated by commas, but this isn't necessary.
	 *
	 *     mode:       typed_literal           // This states the types of the arguments in this literal.  Types are + (an 'input' variable; MUST be present earlier in the clause), - (an 'output' variable; need not already be present in the clause), and # (a constant; need not already be present).    A variable can be followed by '!k' or $k' - the former means &quot;this predicate will be true for EXACTLY k possible values for this argument, where the latter is similar but for &quot;AT MOST K.&quot;
	 *  			   [target=pred/numbArgs]  // Optionally [not yet implemented] can say that the above mode only applies when learning this target.  A sample is 'parentOf/2' (the literal whose predicate name is 'parentOf' and which has two arguments).
	 *  			   [max=#]                 // Optionally say that typed_literal can appear in a learned clauses at most # (some integer) times.
	 *  			   [maxPerInputVars=#]     // Optionally indicate that PER SETTING to the 'input' (i.e. '+') variables, can occur at most this many times (an idea taken from Aleph).
	 */
	private void processMode(List&lt;Sentence&gt; listOfSentences) throws ParsingException, IOException {  // TODO if token not a known optional argument could pushback() w/o needing an EOL, but be more restrictive for now.
<span class="fc" id="L853">		Literal       typedHeadLiteral = processLiteral();</span>
<span class="fc" id="L854">		int           tokenRead    = getNextToken();</span>
<span class="fc" id="L855">		PredicateName targetPred   = null;</span>
<span class="fc" id="L856">		int           arity        = -1; // '-1' means not specified.</span>
<span class="fc" id="L857">		int           max          = Integer.MAX_VALUE;</span>
<span class="fc" id="L858">		int        maxPerInputVars = Integer.MAX_VALUE;</span>

<span class="pc bpc" id="L860" title="1 of 2 branches missed.">		if (!atEOL()) { // Have some optional arguments since not yet at EOL.</span>
<span class="nc" id="L861">			throw new ParsingException(&quot;Deprecated.&quot;);</span>
		}

<span class="pc bpc" id="L864" title="1 of 2 branches missed.">		if (typedHeadLiteral.getArguments() != null) {</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">			for (Term term : typedHeadLiteral.getArguments()) {</span>
<span class="pc bpc" id="L866" title="1 of 2 branches missed.">				if (term instanceof Function) {</span>
					// TODO(hayesall): Where were `Function` used?
<span class="nc" id="L868">					throw new ParsingException(&quot;Deprecated.&quot;);</span>
				}
<span class="pc bpc" id="L870" title="1 of 2 branches missed.">				if (term.getTypeSpec() != null) {</span>
<span class="fc" id="L871">					continue;</span>
				}
<span class="nc" id="L873">				throw new ParsingException(&quot;All arguments in mode specifications must be typed.  There is no type for '&quot; + term + &quot;' in '&quot; + typedHeadLiteral + &quot;'.&quot;);</span>
			}
		}
<span class="fc" id="L876">		stringHandler.recordMode(typedHeadLiteral, max, maxPerInputVars, false);</span>

<span class="fc" id="L878">        listOfSentences.add(stringHandler.getClause(stringHandler.getLiteral(&quot;mode&quot;, typedHeadLiteral.convertToFunction(stringHandler)), true));</span>

		// Do NOT skipToEOL() here since that is what ended the while loop.
<span class="fc" id="L881">	}</span>

	private void processBridger() throws ParsingException, IOException {
<span class="fc" id="L884">		checkForPredicateNamesThatAreCharacters(getNextToken());</span>
		int tokenRead;
<span class="fc" id="L886">		String        currentWord = tokenizer.reportCurrentToken();</span>
<span class="fc" id="L887">		PredicateName predicate = stringHandler.getPredicateName(currentWord);</span>
<span class="fc" id="L888">		tokenRead = getNextToken();</span>

<span class="pc bpc" id="L890" title="1 of 2 branches missed.">		if (tokenRead != '/') { throw new ParsingException(&quot;Expecting a '/' (slash) in a bridger specification for '&quot; + predicate + &quot;', but got: '&quot; + reportLastItemRead() + &quot;'.&quot;); }</span>
<span class="fc" id="L891">		int arity = readInteger();</span>

<span class="fc" id="L893">		predicate.addBridger(arity);</span>
<span class="fc" id="L894">		peekEOL(); // Suck up an optional EOL.</span>
<span class="fc" id="L895">	}</span>

	private void processQueryPred() throws ParsingException, IOException {
<span class="fc" id="L898">		checkForPredicateNamesThatAreCharacters(getNextToken());</span>
		int           tokenRead;
<span class="fc" id="L900">		String        currentWord = tokenizer.reportCurrentToken();</span>
<span class="fc" id="L901">		PredicateName predicate   = stringHandler.getPredicateName(currentWord);</span>
<span class="fc" id="L902">		tokenRead = getNextToken();</span>

<span class="pc bpc" id="L904" title="1 of 2 branches missed.">		if (tokenRead != '/') { throw new ParsingException(&quot;Expecting a '/' (slash) in a query-predicate specification for '&quot; + predicate + &quot;', but got: '&quot; + reportLastItemRead() + &quot;'.&quot;); }</span>
<span class="fc" id="L905">		int arity = readInteger();</span>

<span class="fc" id="L907">		predicate.addQueryPred(arity);</span>
<span class="fc" id="L908">		peekEOL(); // Suck up an optional EOL.</span>
<span class="fc" id="L909">	}</span>

	private int getNextToken() throws IOException {
<span class="fc" id="L912">		return getNextToken(false);</span>
	}

	private int getNextToken(boolean okIfEOF) throws IOException {
<span class="fc" id="L916">		int tokenRead = tokenizer.nextToken();</span>

<span class="pc bpc" id="L918" title="3 of 4 branches missed.">		if (tokenRead == StreamTokenizer.TT_EOF &amp;&amp; !okIfEOF) { throw new IOException(&quot;Unexpected EOF: &quot; + fileName); }</span>
<span class="fc" id="L919">		return tokenRead;</span>
	}

	private int readInteger() throws ParsingException, IOException {
<span class="fc" id="L923">		int   tokenRead = getNextToken();</span>
<span class="fc" id="L924">		boolean negated = false;</span>
<span class="pc bpc" id="L925" title="1 of 2 branches missed.">		if (tokenRead == '-') {</span>
<span class="nc" id="L926">			negated   = true;</span>
<span class="nc" id="L927">			tokenRead = getNextToken();</span>
		}
<span class="pc bpc" id="L929" title="1 of 2 branches missed.">		if (tokenRead == '@') {</span>
<span class="nc" id="L930">			throw new ParsingException(&quot;Deprecated.&quot;);</span>
		}
<span class="pc bpc" id="L932" title="2 of 4 branches missed.">		if (tokenRead != StreamTokenizer.TT_WORD || !isAllDigits(tokenizer.sval())) {</span>
<span class="nc" id="L933">			throw new ParsingException(&quot;Deprecated.&quot;);</span>
		}
<span class="fc" id="L935">		int value = Integer.parseInt(tokenizer.sval());</span>
<span class="pc bpc" id="L936" title="1 of 2 branches missed.">		if (negated) {</span>
<span class="nc" id="L937">			return -value;</span>
		}
<span class="fc" id="L939">		return value;</span>
	}

	/* See if this character is the next one in the stream. If so, &quot;chew it
     * up&quot; and return 'true.' Otherwise push it back and return 'false.'
     */
	private boolean checkAndConsume(char charValue) {
		int tokenRead;
		try {
<span class="fc" id="L948">			tokenRead = getNextToken();</span>
		}
<span class="nc" id="L950">		catch (IOException e) {</span>
<span class="nc" id="L951">			return false; // If at EOF, no need to throw an exception.  Just say nothing to peek at.  TODO - make sure this cant lead to an infinite loop of peek's.</span>
<span class="fc" id="L952">		}</span>
<span class="fc bfc" id="L953" title="All 2 branches covered.">		if (tokenRead == (int)charValue) { return true; }</span>
<span class="fc" id="L954">		tokenizer.pushBack();</span>
<span class="fc" id="L955">		return false;</span>
	}

	/*
         * See if the current token is EOL ('.' or ';').
         *
         * @return Whether the current token in the tokenizer is an end-of-line
         *         marker.
         */
	private boolean atEOL() {
<span class="pc bpc" id="L965" title="1 of 4 branches missed.">		return (tokenizer.ttype() == '.' || tokenizer.ttype() == ';');</span>
	}

	/*
	 * See if next token is an EOL character ('.' or ';').
	 */
	private void peekEOL() throws ParsingException, IOException {
		// TODO(hayesall): Doesn't do much after refactoring.
<span class="fc" id="L973">		int token = tokenizer.nextToken(); // Suck up the EOL if it is next.</span>
<span class="pc bpc" id="L974" title="3 of 4 branches missed.">		if (token == '.' || token == ';') {</span>
<span class="fc" id="L975">			return;</span>
		}
<span class="nc" id="L977">		tokenizer.pushBack();</span>
<span class="nc" id="L978">	}</span>

	private void checkForComma() throws ParsingException {
<span class="fc bfc" id="L981" title="All 2 branches covered.">		if (checkAndConsume(',')) {</span>
<span class="fc" id="L982">			return;</span>
		}
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">		if (checkAndConsume('}')) {</span>
<span class="fc" id="L985">			tokenizer.pushBack(); return;</span>
		}
<span class="nc" id="L987">		throw new ParsingException(&quot;Deprecated.&quot;);</span>
	}

	private boolean isAllDigits(String integerString) {
		// 'parseInt' gets called twice since this is only a boolean, but no big deal to read integer strings twice.
<span class="fc" id="L992">		try { Integer.parseInt(integerString); return true;  }</span>
<span class="fc" id="L993">		catch (NumberFormatException e)     {  return false; }</span>
	}

	private String reportLastItemRead() {
<span class="nc" id="L997">		int tokenRead = tokenizer.ttype();</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">		if (tokenRead == StreamTokenizer.TT_EOF)  {</span>
<span class="nc" id="L999">			return &quot;EOF&quot;;</span>
		}
<span class="nc bnc" id="L1001" title="All 2 branches missed.">		if (tokenRead == StreamTokenizer.TT_WORD) {</span>
<span class="nc" id="L1002">			return tokenizer.sval();</span>
		}
		// Want the character not its integer representation.
<span class="nc" id="L1005">		return String.valueOf((char) tokenRead);</span>
	}

	private boolean isaPossibleTermName(int tokenRead) {
<span class="pc bpc" id="L1009" title="2 of 3 branches missed.">		switch (tokenRead) {</span>
			case '+':
			case '-':
			case '\\':
<span class="nc" id="L1013">				throw new ParsingException(&quot;Deprecated.&quot;);</span>
			case StreamTokenizer.TT_WORD:
<span class="fc" id="L1015">				return true;</span>
			default:
<span class="nc" id="L1017">				return false;</span>
		}
	}

    private boolean checkForOperator() throws ParsingException, IOException {
<span class="pc bpc" id="L1022" title="4 of 8 branches missed.">        return checkToken(&quot;-&quot;) || checkToken(&quot;*&quot;) || checkToken(&quot;/&quot;) || checkToken(&quot;+&quot;);</span>
    }

	private String getPredicateOrFunctionName() throws ParsingException {
<span class="fc" id="L1026">		return getPredicateOrFunctionName(tokenizer.ttype());</span>
	}
	private String getPredicateOrFunctionName(int tokenRead) throws ParsingException {
<span class="pc bpc" id="L1029" title="2 of 3 branches missed.">		switch (tokenRead) {</span>
			// If changed, check out checkForPredicateNamesThatAreCharacters (for cases where a single-char string is returned).
			case StreamTokenizer.TT_WORD:
<span class="fc" id="L1032">				return tokenizer.sval();</span>
			case '-':
			case '\\':
			case '=':
			case '+':
<span class="nc" id="L1037">				throw new ParsingException(&quot;Deprecated.&quot;);</span>
		}
<span class="nc" id="L1039">		throw new ParsingException(&quot;Expecting a predicate name but read: '&quot; + reportLastItemRead() + &quot;'.&quot;);</span>
	}

    private String checkAndConsumeArgumentName() throws IOException {

        String possibleName;

<span class="fc" id="L1046">        int token = getNextToken();</span>
<span class="fc bfc" id="L1047" title="All 2 branches covered.">        if ( token == StreamTokenizer.TT_WORD) {</span>
<span class="fc" id="L1048">            possibleName = tokenizer.reportCurrentToken();</span>
<span class="pc bpc" id="L1049" title="1 of 2 branches missed.">            if ( checkAndConsumeToken(&quot;=&quot;) ) {</span>
<span class="nc" id="L1050">				throw new ParsingException(&quot;Deprecated.&quot;);</span>
            }
        }
<span class="fc" id="L1053">        tokenizer.pushBack();</span>

<span class="fc" id="L1055">        return null;</span>
    }

	private Literal processLiteral() throws ParsingException, IOException {
<span class="fc" id="L1059">		int tokenRead        = getNextToken();</span>
<span class="pc bpc" id="L1060" title="3 of 6 branches missed.">		if (tokenRead == '(' || tokenRead == '{' || tokenRead == '[') {</span>
<span class="nc" id="L1061">			throw new ParsingException(&quot;Deprecated.&quot;);</span>
		}

<span class="fc" id="L1064">		tokenRead = checkForPredicateNamesThatAreCharacters(tokenRead);</span>
<span class="fc" id="L1065">		Term possibleTerm     = processRestOfTerm(tokenRead, false); // WHY????? argumentsMustBeTyped);</span>
<span class="fc" id="L1066">		tokenRead             = getNextToken(true);</span>

<span class="pc bpc" id="L1068" title="1 of 2 branches missed.">		if (tokenRead == StreamTokenizer.TT_EOF) { return convertTermToLiteral(possibleTerm); }</span>
<span class="fc" id="L1069">		String peekAtNextWord = isInfixTokenPredicate(tokenRead);</span>
<span class="pc bpc" id="L1070" title="1 of 2 branches missed.">		if (peekAtNextWord != null) { // Handle 'is' and &lt;, &gt;, &gt;=, &lt;=, ==, etc.</span>
<span class="nc" id="L1071">			throw new ParsingException(&quot;Deprecated.&quot;);</span>
		}
<span class="fc" id="L1073">		tokenizer.pushBack();</span>
<span class="fc" id="L1074">		return convertTermToLiteral(possibleTerm);</span>
	}

    private NamedTermList processListOfTerms(boolean argumentsMustBeTyped) throws ParsingException, IOException {

<span class="fc" id="L1079">        List&lt;Term&gt; terms = new ArrayList&lt;&gt;();</span>

		Term t;
        String name;

<span class="fc" id="L1084">        boolean done = false;</span>

<span class="fc" id="L1086">        String closingBracketChar = Character.toString(')');</span>

        // We check immediate for a closing bracket to
        // support literals written as:  x() although
        // this is illegal in prolog.
<span class="pc bpc" id="L1091" title="1 of 2 branches missed.">        if (checkAndConsumeToken(closingBracketChar)) {</span>
<span class="nc" id="L1092">			throw new ParsingException(&quot;Deprecated.&quot;);</span>
        }

<span class="fc bfc" id="L1095" title="All 2 branches covered.">        while (!done) {</span>
            // Look for a name?
<span class="fc" id="L1097">            name = checkAndConsumeArgumentName();</span>
<span class="fc" id="L1098">            t = processTerm(argumentsMustBeTyped);</span>

<span class="fc" id="L1100">            terms.add(t);</span>

<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">            if (name != null) {</span>
<span class="nc" id="L1103">				throw new ParsingException(&quot;Deprecated.&quot;);</span>
            }

<span class="fc bfc" id="L1106" title="All 2 branches covered.">            if (checkAndConsumeToken(closingBracketChar)) {</span>
<span class="fc" id="L1107">                done = true;</span>
            }
<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">            else if (!checkToken(&quot;,&quot;)) {</span>
<span class="nc" id="L1110">				throw new ParsingException(&quot;Deprecated.&quot;);</span>
            }
            else {
<span class="fc" id="L1113">                expectAndConsumeToken(&quot;,&quot;);</span>
            }
        }

<span class="fc" id="L1117">        return new NamedTermList(terms);</span>
    }

	/*
	 * Is the current token an indicator of a type specification? E.g., see TypeSpec.isaModeSpec for the full list.
	 */
	private boolean atTypeSpec() throws IOException {
<span class="fc" id="L1124">		int tokenRead = tokenizer.ttype();</span>
<span class="fc bfc" id="L1125" title="All 4 branches covered.">		if (tokenRead == '+' || tokenRead == '-') {</span>
<span class="pc bpc" id="L1126" title="1 of 2 branches missed.">			if (tokenizer.prevToken() == '\\') {</span>
<span class="nc" id="L1127">				throw new ParsingException(&quot;Deprecated.&quot;);</span>
			}
			// If '+' or '-' need to see if the next item is a string of digits.
<span class="fc" id="L1130">			int nextToken  = getNextToken();</span>
<span class="pc bpc" id="L1131" title="1 of 4 branches missed.">			if (nextToken == StreamTokenizer.TT_WORD &amp;&amp; isAllDigits(tokenizer.sval())) {  // This '+' or '-' is a sign in front of some digits.</span>
<span class="fc" id="L1132">				tokenizer.pushBack();</span>
<span class="fc" id="L1133">				return false;</span>
			}
<span class="fc" id="L1135">			tokenizer.pushBack();</span>
<span class="fc" id="L1136">			return true;</span>
		}
<span class="fc" id="L1138">		return TypeSpec.isaModeSpec((char) tokenRead);</span>
	}

	private TypeSpec getTypeSpec(int tokenRead, StreamTokenizerJWS tokenizer) throws ParsingException, IOException {
<span class="fc" id="L1142">		char modeAsChar = (char)tokenRead;</span>
<span class="fc" id="L1143">		int nextTokenRead = getNextToken();</span>
<span class="pc bpc" id="L1144" title="1 of 2 branches missed.">		if (nextTokenRead != StreamTokenizer.TT_WORD) {</span>
<span class="nc" id="L1145">			throw new ParsingException(&quot;Expecting a type in a typed term (e.g., 'human' in '+human:John'), but instead got: '&quot; + reportLastItemRead() + &quot;'.&quot;);</span>
		}
<span class="fc" id="L1147">		return new TypeSpec(modeAsChar, tokenizer.sval(), stringHandler);</span>
	}

	// At one time this was being considered for sharing as a utility, which is why it is a static.
	// But HandleFOPCstrings.getNumericConstant handles converting to int's when appropriate.
	private static NumericConstant convertToNumericConstant(HandleFOPCstrings stringHandler, TypeSpec typeSpec, double value) {
<span class="fc" id="L1153">		return stringHandler.getNumericConstant(typeSpec, value);</span>
	}

   // Terms can be wrapped in parentheses.
    private Term processTerm(boolean argumentsMustBeTyped) throws ParsingException, IOException {
<span class="fc" id="L1158">        int tokenRead = getNextToken();</span>
<span class="pc bpc" id="L1159" title="4 of 5 branches missed.">        switch (tokenRead) {</span>
            case '(': // Handle parentheses.
<span class="nc" id="L1161">				throw new ParsingException(&quot;Deprecated.&quot;);</span>
            case '{':
<span class="nc" id="L1163">				throw new ParsingException(&quot;Deprecated.&quot;);</span>
            case '[': // Process a list.
<span class="nc" id="L1165">				throw new ParsingException(&quot;Deprecated.&quot;);</span>
            case '\\': // Could be \+().
            case '\'':
            case '&quot;':
            case '-':
            case '+':
            case '=':
            case '#': // Have to include the possible type specs here...
            case '&amp;': // Have to include the possible type specs here...
            case '*': // Have to include the possible type specs here...
            case '^': // Have to include the possible type specs here...
            case ':': // Have to include the possible type specs here...
            case '$': // Have to include the possible type specs here...
            case '@': // Have to include the possible type specs here...
            case '`': // Have to include the possible type specs here...
            case '&gt;': // Have to include the possible type specs here...
            case StreamTokenizer.TT_WORD:
<span class="fc" id="L1182">                Term result = processRestOfTerm(tokenRead, argumentsMustBeTyped);</span>
<span class="pc bpc" id="L1183" title="1 of 2 branches missed.">                if ( checkForOperator() ) {</span>
<span class="nc" id="L1184">					throw new ParsingException(&quot;Deprecated.&quot;);</span>
                }
<span class="fc" id="L1186">                return result;</span>
            default:
<span class="nc" id="L1188">				throw new ParsingException(&quot;Deprecated.&quot;);</span>
        }
    }

	/**
	 * A typeSpec can be followed with a !k or $k.  The former means the predicate &quot;wrapping&quot; this argument is true for EXACTLY k settings of this argument.  The latter is similar, except it the predicate is true for AT MOST k settings.
	 */
	private void checkForLimitOnNumberOfTrueSettings(TypeSpec typeSpec) throws ParsingException {
		// TODO(hayesall): Deprecate and remove.
<span class="fc bfc" id="L1197" title="All 2 branches covered.">		if (typeSpec == null) {</span>
<span class="fc" id="L1198">			return;</span>
		}
<span class="pc bpc" id="L1200" title="1 of 2 branches missed.">		if (checkAndConsume('!')) {</span>
<span class="nc" id="L1201">			throw new ParsingException(&quot;Deprecated.&quot;);</span>
<span class="pc bpc" id="L1202" title="1 of 2 branches missed.">		} else if (checkAndConsume('$')) {</span>
<span class="nc" id="L1203">			throw new ParsingException(&quot;Deprecated.&quot;);</span>
		}
<span class="fc" id="L1205">	}</span>

	/*
	 * Read the REST of a term. The first token read is provided. If
	 * argumentsMustBeTyped=true, any arguments must be typed (e.g.,
	 * human:John).
	 */
	private Term processRestOfTerm(int tokenRead, boolean argumentsMustBeTyped) throws ParsingException, IOException {
<span class="fc" id="L1213">		return processRestOfTerm(tokenRead, argumentsMustBeTyped, false);</span>
	}
	private Term processRestOfTerm(int tokenRead, boolean argumentsMustBeTyped, boolean calledFromInsideMathExpression) throws ParsingException, IOException {
<span class="fc" id="L1216">		int      negate    = 1;</span>
<span class="fc" id="L1217">		TypeSpec typeSpec  = null;</span>
<span class="fc" id="L1218">		boolean  skippedOverPlusSign = false;</span>

<span class="pc bpc" id="L1220" title="1 of 4 branches missed.">		if (argumentsMustBeTyped || atTypeSpec()) { // Also look for OPTIONAL typed terms.</span>
<span class="fc" id="L1221">			typeSpec  = getTypeSpec(tokenRead, tokenizer);</span>
<span class="pc bpc" id="L1222" title="1 of 2 branches missed.">			if (!checkAndConsume(':')) { // Just a type specification here, so done with the term.</span>
<span class="fc" id="L1223">				Term result = stringHandler.getAnonymousTerm(typeSpec);</span>
<span class="fc" id="L1224">				checkForLimitOnNumberOfTrueSettings(typeSpec);</span>
<span class="fc" id="L1225">				return result;</span>
			}
<span class="nc" id="L1227">			tokenRead = getNextToken();</span>
		}
<span class="pc bpc" id="L1229" title="1 of 2 branches missed.">		if (atQuotedString(tokenRead)) {</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">			return stringHandler.getStringConstant(typeSpec, (char)tokenRead + tokenizer.svalQuoted() + (char)tokenRead, !stringHandler.keepQuoteMarks);</span>
		}

<span class="fc bfc" id="L1233" title="All 2 branches covered.">		if (tokenRead == '-')  { // Have a minus sign.  Since this is a logical expression, can only be negating a number.</span>
<span class="fc" id="L1234">			negate    = -1;</span>
<span class="fc" id="L1235">			tokenRead = getNextToken();</span>
		}
<span class="pc bpc" id="L1237" title="3 of 4 branches missed.">		if (tokenRead == '+' &amp;&amp; tokenizer.prevToken() != '\\') {  // Just a plus sign that can be ignored (note: we confirmed it isn't the built-in &quot;\+&quot; predicate).</span>
<span class="nc" id="L1238">			tokenRead = getNextToken();</span>
<span class="nc" id="L1239">			skippedOverPlusSign = true;</span>
		}
<span class="pc bpc" id="L1241" title="1 of 2 branches missed.">		if (!isaPossibleTermName(tokenRead)) { throw new ParsingException(&quot;Expecting a term or literal name but read: '&quot; + reportLastItemRead() + &quot;'.&quot;); }</span>

		// See if the next word read can be viewed as an integer or double.
<span class="fc" id="L1244">		double resultAsNumber = processNumber(tokenRead);</span>
<span class="fc bfc" id="L1245" title="All 2 branches covered.">		if (Utils.isaNumber(resultAsNumber)) {</span>
<span class="fc" id="L1246">			return convertToNumericConstant(stringHandler, typeSpec, negate * resultAsNumber);</span>
		}
<span class="fc" id="L1248">		String wordRead = getPredicateOrFunctionName(tokenRead);</span>
<span class="pc bpc" id="L1249" title="1 of 2 branches missed.">		if (negate == -1)        { throw new ParsingException(&quot;Read an unexpected '-' when parsing a term.&quot;); }</span>
<span class="pc bpc" id="L1250" title="1 of 2 branches missed.">		if (skippedOverPlusSign) { throw new ParsingException(&quot;Read an unexpected '+' when parsing a term.&quot;); }</span>
<span class="fc bfc" id="L1251" title="All 2 branches covered.">		if (checkAndConsume('(')) { // See if this is a function.</span>
<span class="fc" id="L1252">			FunctionName fName = stringHandler.getFunctionName(wordRead);</span>
			List&lt;Term&gt;   arguments;
			List&lt;String&gt; names;
			// ONCE is really more of a connective than a predicate, but since it is the only prefix-based connective, treat it here.
<span class="pc bpc" id="L1256" title="1 of 2 branches missed.">			if (wordRead.equalsIgnoreCase(&quot;once&quot;)) { // A once() needs to have an argument that is an FOPC clause.</span>
<span class="nc" id="L1257">				throw new ParsingException(&quot;Deprecated&quot;);</span>
<span class="pc bpc" id="L1258" title="1 of 2 branches missed.">			} else if (wordRead.equalsIgnoreCase(&quot;call&quot;)) {</span>
<span class="nc" id="L1259">				throw new ParsingException(&quot;Deprecated&quot;);</span>
<span class="pc bpc" id="L1260" title="2 of 4 branches missed.">			} else if (wordRead.equalsIgnoreCase(&quot;findAll&quot;) || wordRead.equalsIgnoreCase(&quot;all&quot;)   ||</span>
<span class="pc bpc" id="L1261" title="2 of 4 branches missed.">				       wordRead.equalsIgnoreCase(&quot;bagOf&quot;)   || wordRead.equalsIgnoreCase(&quot;setOf&quot;)) { // A findAll(), etc. needs to have an SECOND argument that is an FOPC clause.</span>
<span class="nc" id="L1262">				throw new ParsingException(&quot;Deprecated&quot;);</span>
			}
<span class="pc bpc" id="L1264" title="2 of 4 branches missed.">			else if (wordRead.equalsIgnoreCase(&quot;countProofs&quot;) || wordRead.equalsIgnoreCase(&quot;countUniqueBindings&quot;)) { // A countProofs() needs to have an FIRST argument that is an FOPC clause.</span>
<span class="nc" id="L1265">				throw new ParsingException(&quot;Deprecated&quot;);</span>
			}
			else {
<span class="fc" id="L1268">				 NamedTermList namedTermList = processListOfTerms(argumentsMustBeTyped); // This should suck up the closing parenthesis.</span>
<span class="fc" id="L1269">				 arguments = namedTermList.getTerms();</span>
<span class="fc" id="L1270">				 names     = null;</span>
			}
<span class="fc" id="L1272">			checkForLimitOnNumberOfTrueSettings(typeSpec); // Look for a training !k or $k.</span>
<span class="fc" id="L1273">			return stringHandler.getFunction(fName, arguments, names, typeSpec);</span>
		}
<span class="pc bpc" id="L1275" title="2 of 4 branches missed.">		else if (!calledFromInsideMathExpression &amp;&amp; peekIfAtInfixMathSymbol()) {</span>
<span class="nc" id="L1276">			throw new ParsingException(&quot;Deprecated.&quot;);</span>
		}
<span class="fc" id="L1278">		checkForLimitOnNumberOfTrueSettings(typeSpec);</span>
<span class="fc" id="L1279">		return stringHandler.getVariableOrConstant(typeSpec, wordRead);  // If the next character isn't an open parenthesis, then have a constant or a variable.</span>
	}

	private boolean peekIfAtInfixMathSymbol() throws IOException {
<span class="fc" id="L1283">		int tokenRead = getNextToken();</span>
<span class="pc bpc" id="L1284" title="1 of 2 branches missed.">		switch (tokenRead) {</span>
			case '+':
			case '-':
			case '*':
<span class="nc" id="L1288">			case '/': return true;</span>
		}
<span class="fc" id="L1290">		tokenizer.pushBack();</span>
<span class="fc" id="L1291">		return false;</span>
	}

	private boolean atQuotedString(int token) {
		// TODO(hayesall): Deprecate.
<span class="pc bpc" id="L1296" title="1 of 2 branches missed.">		return token == '&quot;' || (FileParser.allowSingleQuotes &amp;&amp; token == '\'');</span>
	}

	/*
	 * If reading a string, possibly quoted, return it.  If not a string, complain if requested; otherwise return null.
	 */
	private String getPossiblyQuotedString(int tokenRead) throws ParsingException {
<span class="pc bpc" id="L1303" title="1 of 2 branches missed.">		if (atQuotedString(tokenRead)) {</span>
<span class="nc" id="L1304">			return (char)tokenRead + tokenizer.svalQuoted() + (char)tokenRead;</span>
		}
		try {
<span class="fc" id="L1307">			double result = processNumber(tokenRead);</span>
<span class="pc bpc" id="L1308" title="1 of 2 branches missed.">			if (!Double.isNaN(result)) { return Double.toString(result); }</span>
<span class="nc" id="L1309">		} catch (Exception ignored) {</span>
<span class="fc" id="L1310">		}</span>

<span class="pc bpc" id="L1312" title="1 of 2 branches missed.">		if (tokenRead != StreamTokenizer.TT_WORD) {</span>
<span class="nc" id="L1313">			throw new ParsingException(&quot;Expecting the name of a type, but got: &quot; + reportLastItemRead() + &quot;.&quot;);</span>
		}
<span class="fc" id="L1315">		return tokenizer.sval();</span>
	}

	// Note that NOT is also handled here.
    private ConnectiveName processPossibleConnective(int tokenRead) throws ParsingException, IOException {
<span class="pc bpc" id="L1320" title="1 of 5 branches missed.">		switch (tokenRead) {</span>
			case StreamTokenizer.TT_WORD:
<span class="fc" id="L1322">				String candidate = tokenizer.sval();</span>
<span class="pc bpc" id="L1323" title="1 of 2 branches missed.">				if (ConnectiveName.isaConnective(candidate)) {</span>
<span class="nc" id="L1324">					throw new ParsingException(&quot;Deprecated.&quot;);</span>
				}
<span class="fc" id="L1326">				return null;</span>
			case '^':
			case '&amp;':
			case ',':
			case '~':
				// TODO(hayesall): What is this?
<span class="fc" id="L1332">				return stringHandler.getConnectiveName(String.valueOf((char)tokenRead));</span>
			case '-':
			case '\\':
			case '=':
			case '&lt;':
<span class="nc" id="L1337">				throw new ParsingException(&quot;Deprecated&quot;);</span>
			case ':':
<span class="fc" id="L1339">				tokenRead = getNextToken();</span>
<span class="pc bpc" id="L1340" title="1 of 2 branches missed.">				if (tokenRead == '=') {</span>
<span class="nc" id="L1341">					throw new ParsingException(&quot;Deprecated&quot;);</span>
				}
<span class="pc bpc" id="L1343" title="1 of 2 branches missed.">				if (tokenRead == '-') {</span>
<span class="fc" id="L1344">					return stringHandler.getConnectiveName(&quot;:-&quot;);</span>
				}
<span class="nc" id="L1346">				throw new ParsingException(&quot;Deprecated&quot;);</span>
			default:
<span class="fc" id="L1348">				return null;</span>
		}
	}

	private Sentence processFOPC_sentence(int insideLeftParenCount) throws ParsingException, IOException {
<span class="fc" id="L1353">		List&lt;AllOfFOPC&gt; accumulator = new ArrayList&lt;&gt;(4);</span>
<span class="fc" id="L1354">		boolean         lookingForConnective = false;</span>
		while (true) {
			// PFS = processFOPC_sentence
<span class="fc" id="L1357">			int tokenRead = getNextToken();</span>
<span class="fc" id="L1358">			ConnectiveName connective = processPossibleConnective(tokenRead);</span>
<span class="fc bfc" id="L1359" title="All 2 branches covered.">			if (connective != null) {</span>
				// OK to have NOT or '~' be the first item and OK to have any number of NOT's in a row.
<span class="pc bpc" id="L1361" title="5 of 6 branches missed.">    			if (!lookingForConnective &amp;&amp; accumulator.size() &gt; 0 &amp;&amp; !ConnectiveName.isaNOT(connective.name)) {</span>
<span class="nc" id="L1362">					throw new ParsingException(&quot;Encountered two logical connectives in a row: '&quot; + accumulator.get(accumulator.size() - 1) + &quot;' and '&quot; + connective + &quot;'.&quot;);</span>
				}
<span class="pc bpc" id="L1364" title="3 of 4 branches missed.">            	if (accumulator.isEmpty() &amp;&amp; !ConnectiveName.isaNOT(connective.name)) {</span>
<span class="nc" id="L1365">					throw new ParsingException(&quot;Encountered '&quot; + connective + &quot;' as the FIRST connective.&quot;);</span>
				}
<span class="fc" id="L1367">            	accumulator.add(connective);</span>
<span class="fc" id="L1368">    			lookingForConnective = false;</span>
            }
            else {
            	// First see if dealing with an in-fix predicate.
<span class="fc" id="L1372">            	String peekAtNextWord = isInfixTokenPredicate(tokenRead);</span>
<span class="pc bpc" id="L1373" title="1 of 2 branches missed.">            	if (peekAtNextWord != null) {</span>
<span class="nc" id="L1374">					throw new ParsingException(&quot;Deprecated&quot;);</span>
            	}
            	else {
<span class="pc bpc" id="L1377" title="2 of 7 branches missed.">            		switch (tokenRead) {</span>
            			case '(':
            			case '{':
            			case '[':
<span class="fc" id="L1381">            				Sentence resultLeftParens = processFOPC_sentence(insideLeftParenCount + 1); // Parse up to the closing right parenthesis.</span>
<span class="fc" id="L1382">							accumulator.add(resultLeftParens);</span>
<span class="fc" id="L1383">							break;</span>
            			case ')':
            			case '}':
            			case ']':
<span class="pc bpc" id="L1387" title="1 of 2 branches missed.">            				if (insideLeftParenCount == 0) {</span>
<span class="nc" id="L1388">								throw new ParsingException(&quot;Deprecated&quot;);</span>
            				}
<span class="fc" id="L1390">							return convertAccumulatorToFOPC(accumulator);</span>
            			case '.':
            			case ';':
<span class="fc" id="L1393">            				tokenizer.pushBack(); // Push this back.  It might be used to close several quantifiers.  If doing a top-level call, that call can such this up.</span>
<span class="fc" id="L1394">							return convertAccumulatorToFOPC(accumulator);</span>
            			case '!': // Prolog's 'cut'.
<span class="fc" id="L1396">            				PredicateName pName = stringHandler.standardPredicateNames.cut;</span>
<span class="fc" id="L1397">            				Literal lit = stringHandler.getLiteral(pName);</span>
<span class="fc" id="L1398">            				accumulator.add(lit);</span>
<span class="fc" id="L1399">            				break;</span>
            			case '+': // Could have something like '+5 &lt; y'
            			case '-': // Or, more likely, '-5 &lt; y'  Or this could be a &quot;bare&quot; weight on a sentence.
            			case '\\': // Might be \+().
            			case StreamTokenizer.TT_WORD:
<span class="fc" id="L1404">            				Sentence s = processFOPC_sentenceFromThisToken();</span>
<span class="fc" id="L1405">            				accumulator.add(s);</span>
<span class="fc" id="L1406">            				break;</span>
            			case ':':
<span class="nc" id="L1408">            				throw new ParsingException(&quot;Unexpectedly read ':'.  The previous token might be a misspelling of a keyword.  Have accumulated these tokens: &quot; + accumulator);</span>
            			default:
<span class="nc" id="L1410">                            throw new ParsingException(&quot;Expecting a part of an FOPC sentence, but read the unexpected character: '&quot; + reportLastItemRead() + &quot;'.&quot;);</span>
            		}
<span class="pc bpc" id="L1412" title="1 of 2 branches missed.">            		if (lookingForConnective) {</span>
<span class="nc" id="L1413">						throw new ParsingException(&quot;Encountered two FOPC sentences in a row: '&quot; + accumulator.get(accumulator.size() - 2) + &quot;' and '&quot; + accumulator.get(accumulator.size() - 1) + &quot;'.&quot;);</span>
					}
            	}
<span class="fc" id="L1416">            	lookingForConnective = true;</span>
            }
<span class="fc" id="L1418">		}</span>
	}

	private Sentence processFOPC_sentenceFromThisToken() throws ParsingException, IOException {
<span class="fc" id="L1422">		String currentWord = getPredicateOrFunctionName(); // This will only be called if reading a string (which might be representing a number).</span>
		// Quantifiers are scoped to go to the next EOL unless parenthesis limit the scope.
<span class="pc bpc" id="L1424" title="1 of 2 branches missed.">		if (currentWord.equalsIgnoreCase(&quot;ForAll&quot;)) {</span>
<span class="nc" id="L1425">			throw new ParsingException(&quot;Deprecated&quot;);</span>
		}
<span class="pc bpc" id="L1427" title="3 of 6 branches missed.">		else if (currentWord.equalsIgnoreCase(&quot;ThereExists&quot;) || currentWord.equalsIgnoreCase(&quot;Exists&quot;) || currentWord.equalsIgnoreCase(&quot;Exist&quot;)) { // Note: 'Exist' allowed since that is what Alchemy uses.</span>
<span class="nc" id="L1428">			throw new ParsingException(&quot;Deprecated&quot;);</span>
		} else {
            // See if this is an in-fix literal.
<span class="fc" id="L1431">            Term possibleTerm = processRestOfTerm(tokenizer.ttype(), false);</span>
<span class="fc" id="L1432">            int tokenRead = getNextToken();</span>
<span class="fc" id="L1433">            String peekAtNextWord = isInfixTokenPredicate(tokenRead);</span>
<span class="pc bpc" id="L1434" title="1 of 2 branches missed.">            if (peekAtNextWord != null) { // Handle 'is' and { &lt;, &gt;, &gt;=, &lt;=, == }.</span>
<span class="nc" id="L1435">				throw new ParsingException(&quot;Deprecated&quot;);</span>
            }
<span class="fc" id="L1437">            tokenizer.pushBack(); // Undo the getNextToken() that checked for an infix predicate.</span>

<span class="pc bpc" id="L1439" title="1 of 2 branches missed.">            if (possibleTerm instanceof NumericConstant) { // If reading a number and not in an in-fix (e.g., '5 &lt;= 6') then interpret as a weighted sentence.</span>
				// TODO(hayesall): Where else is NumericConstant used?
<span class="nc" id="L1441">				throw new ParsingException(&quot;Deprecated&quot;);</span>
            } else {
<span class="fc" id="L1443">                return convertTermToLiteral(possibleTerm);</span>
            }
        }
	}

	private Literal convertTermToLiteral(Term term) throws ParsingException {
<span class="pc bpc" id="L1449" title="1 of 2 branches missed.">		if (term instanceof Function) {</span>
<span class="fc" id="L1450">			PredicateName pName = stringHandler.getPredicateName(((Function) term).functionName.name);</span>
<span class="fc" id="L1451">			Function      f     = (Function) term;</span>
<span class="fc" id="L1452">			return stringHandler.getLiteral(pName, f.getArguments(), f.getArgumentNames());</span>
		} else {
<span class="nc" id="L1454">			throw new ParsingException(&quot;Deprecated.&quot;);</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>