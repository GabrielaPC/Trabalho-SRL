<?xml version="1.0" encoding="UTF-8"?>
<testsuite name="edu.wisc.cs.will.ToyFatherMLNTest" tests="1" skipped="0" failures="0" errors="0" timestamp="2022-10-20T17:10:39" hostname="Ubuntu" time="0.415">
  <properties/>
  <testcase name="testToyFatherMLNLearnInfer()" classname="edu.wisc.cs.will.ToyFatherMLNTest" time="0.415"/>
  <system-out><![CDATA[
% Calling SETUP.

% Switching to VarIndicator = uppercase.

% Unset'ing VarIndicator.

Resetting the LazyGroundNthArgumentClauseIndex.

% Calling ILPouterLoop from createRegressionOuterLooper.

% getInputArgWithDefaultValue: args=[data/toy_father/train/train_pos.txt, data/toy_father/train/train_neg.txt, data/toy_father/train/train_bk.txt, data/toy_father/train/train_facts.txt]
%  for N=0: args[N]=data/toy_father/train/train_pos.txt

% getInputArgWithDefaultValue: args=[data/toy_father/train/train_pos.txt, data/toy_father/train/train_neg.txt, data/toy_father/train/train_bk.txt, data/toy_father/train/train_facts.txt]
%  for N=1: args[N]=data/toy_father/train/train_neg.txt

% getInputArgWithDefaultValue: args=[data/toy_father/train/train_pos.txt, data/toy_father/train/train_neg.txt, data/toy_father/train/train_bk.txt, data/toy_father/train/train_facts.txt]
%  for N=2: args[N]=data/toy_father/train/train_bk.txt

% getInputArgWithDefaultValue: args=[data/toy_father/train/train_pos.txt, data/toy_father/train/train_neg.txt, data/toy_father/train/train_bk.txt, data/toy_father/train/train_facts.txt]
%  for N=3: args[N]=data/toy_father/train/train_facts.txt

% Welcome to the WILL ILP/SRL systems.

% Reading background theory from dir: null

% Switching to VarIndicator = uppercase.

***** Warning: % Since this is the first setting of the notation for variables, will keep:
%   variableIndicator = uppercase *****

% [ LazyGroundClauseIndex ]  Building full index for mode/1 with 1 assertions.

%  Read the facts.
%  Have read 41 facts.
% Have read 5 examples from 'data/toy_father/train' [data/toy_father/train/train*].
% Have read 21 examples from 'data/toy_father/train' [data/toy_father/train/train*].

%  LearnOneClause initialized.

% The outer looper has been created.

% Initializing the ILP inner looper.

% NEW target:                 father(A, B)
%  targetPred:                father/2
%  targetArgTypes:            signature = [const, const], types = [+name, +name]
%  targets:                   [father(A, B)]
%  targetPredicates:          [father/2]
%  targetArgSpecs:            [[A[+name], B[+name]]]
%  variablesInTargets:        [[A, B]]

% Started collecting constants

% Collecting the types of constants.

% Looking at the training examples to see if any types of new constants can be inferred.
% Time to collect constants: 0 seconds

% Read 5 pos examples and 21 neg examples.
% Time to init learnOneClause: 2 milliseconds
% Old dirnull
Setting model dir

% Have 5 'raw' positive examples and kept 5.
% Have 21 'raw' negative examples and kept 21.

% processing backup's for father
%  POS EX = 5
%  NEG EX = 21

% Memory usage by WILLSetup (just counts # targets?):
%  |backupPosExamples| = 1
%  |backupNegExamples| = 1
%  |predicatesAsFacts| = 0
%  |addedToFactBase|   = 0
data/toy_father/train/models/
% Learning 10 trees in this iteration for father

% Learn model for: father
% Kept 5 of the 5 positive examples.
% Kept 9 of the 21 negative examples.
% Have prepared facts.
%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.22959183673469388
Set score:0.0025
% Dataset size: 14
Computing probabilities
prob time:1 milliseconds
No hidden examples for : father
Time to build dataset: 1 milliseconds
%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.2295918367346937
Set score:0.0025

% Have these 10 positive seeds: 0 3 5 6 7 8 9 10 11 12

% LearnOneClause Parameters:
%   Targets (1):
%    father(+name, +name)
%  Modes (3):
%    male(+name),
%    childof(+name, +name),
%    siblingof(+name, -name)

% target           = father(A, B)
%     Score = -Infinity (regressionFit = Infinity, penalties=2.2E-7) for clause:  father(_, _).  [covers 14,0/14,0 pos, 0,0/0,0 neg]
% Most-general root: father(_, _).  [covers 14,0/14,0 pos, 0,0/0,0 neg]  score = -Infinity
% [ LazyGroundClauseIndex ]  Building full index for male/1 with 13 assertions.
% [ LazyGroundClauseIndex ]  Building full index for childof/2 with 16 assertions.
% [ LazyGroundClauseIndex ]  Building full index for siblingof/2 with 12 assertions.
% [ LazyGroundNthArgumentClauseIndex ]  Argument 0:  Building full index for siblingof/2.
%     Score = -3,212122 (regressionFit = 3,212121, penalties=1.12E-6) for clause:  father(A, _) :- male(A).  [covers 11,0/14,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -3,212122): father(A, _) :- male(A).  [covers 11,0/14,0 pos, 0,0/0,0 neg]
%     Score = -2,500001 (regressionFit = 2,500000, penalties=1.12E-6) for clause:  father(_, A) :- male(A).  [covers 10,0/14,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -2,500001): father(_, A) :- male(A).  [covers 10,0/14,0 pos, 0,0/0,0 neg]
%     Score = -1,428572 (regressionFit = 1,428571, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- childof(B, A).  [covers 7,0/14,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -1,428572): father(A, B) :- childof(B, A).  [covers 7,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- siblingof(A, B).  [covers 1,0/14,0 pos, 0,0/0,0 neg]
%     Score = -3,208335 (regressionFit = 3,208333, penalties=1.23E-6) for clause:  father(A, _) :- siblingof(A, _).  [covers 8,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- siblingof(B, A).  [covers 1,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.23E-6) for clause:  father(_, A) :- siblingof(A, _).  [covers 1,0/14,0 pos, 0,0/0,0 neg]
%     Score = -1,688891 (regressionFit = 1,688889, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(A).  [covers 5,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,000002 (regressionFit = 0,000000, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(B).  [covers 5,0/14,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,000002): father(A, B) :- childof(B, A), male(B).  [covers 5,0/14,0 pos, 0,0/0,0 neg]
%     Score = -1,636366 (regressionFit = 1,636364, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- childof(B, A), siblingof(A, _).  [covers 3,0/14,0 pos, 0,0/0,0 neg]
%     Score = -2,833335 (regressionFit = 2,833333, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(B), male(A).  [covers 8,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,000002 (regressionFit = 0,000000, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), childof(B, A).  [covers 5,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), siblingof(A, B).  [covers 1,0/14,0 pos, 0,0/0,0 neg]
%     Score = -3,000002 (regressionFit = 3,000000, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(B), siblingof(A, _).  [covers 6,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), siblingof(B, A).  [covers 1,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.2300000000000002E-6) for clause:  father(_, A) :- male(A), siblingof(A, _).  [covers 1,0/14,0 pos, 0,0/0,0 neg]
%     Score = -3,190061 (regressionFit = 3,190059, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- siblingof(A, _), male(A).  [covers 6,0/14,0 pos, 0,0/0,0 neg]
%     Score = -3,089877 (regressionFit = 3,089875, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), male(B).  [covers 6,0/14,0 pos, 0,0/0,0 neg]
%     Score = -3,172418 (regressionFit = 3,172416, penalties=2.1300000000000004E-6) for clause:  father(A, _) :- siblingof(A, B), male(B).  [covers 8,0/14,0 pos, 0,0/0,0 neg]
%     Score = -1,635149 (regressionFit = 1,635147, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), childof(B, A).  [covers 3,0/14,0 pos, 0,0/0,0 neg]
% [ LazyGroundNthArgumentClauseIndex ]  Argument 0:  Building full index for childof/2.
%     Score = -1,635149 (regressionFit = 1,635147, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, C), childof(B, C).  [covers 3,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(A, B).  [covers 1,0/14,0 pos, 0,0/0,0 neg]
%     Score = -3,208336 (regressionFit = 3,208333, penalties=2.24E-6) for clause:  father(A, _) :- siblingof(A, _), siblingof(A, _).  [covers 8,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(B, A).  [covers 1,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(A, C), siblingof(B, C).  [covers 1,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.1400000000000003E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(B, _).  [covers 1,0/14,0 pos, 0,0/0,0 neg]
% [ LazyGroundNthArgumentClauseIndex ]  Argument 1:  Building full index for siblingof/2.
%     Score = -3,208335 (regressionFit = 3,208333, penalties=2.0300000000000005E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, A).  [covers 8,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(A, C), siblingof(C, B).  [covers 1,0/14,0 pos, 0,0/0,0 neg]
%     Score = -3,208335 (regressionFit = 3,208333, penalties=2.1400000000000003E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, _).  [covers 8,0/14,0 pos, 0,0/0,0 neg]
%     Score = -2,833335 (regressionFit = 2,833333, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(A), male(B).  [covers 8,0/14,0 pos, 0,0/0,0 neg]
%     Score = -1,688891 (regressionFit = 1,688889, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), childof(B, A).  [covers 5,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), siblingof(A, B).  [covers 1,0/14,0 pos, 0,0/0,0 neg]
%     Score = -3,208336 (regressionFit = 3,208333, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- male(A), siblingof(A, _).  [covers 6,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), siblingof(B, A).  [covers 1,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(A), siblingof(B, _).  [covers 1,0/14,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- childof(B, A), male(B).  [covers 5,0/14,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- childof(B, A), male(B).  [covers 5,0/14,0 pos, 0,0/0,0 neg]

% Expanding node at Level 0 with score = 1,797693e+308.
% Will extend: father(A, B) :- childof(B, A), male(B).  [covers 5,0/14,0 pos, 0,0/0,0 neg]
Comparing variance: 0.0 to score=0.0025 #egs=5.0
Comparing variance: -9.25185853854297E-18 to score=0.0025 #egs=9.0
%   Creating a TRUE-branch leaf because wgtedCountTrueBranchPos = 5,0 < 2.1 * minPosCov = 6,3
%   Creating a FALSE-branch leaf because good enough fit since score < 0.0025

% Time for loop #1: 25 milliseconds.
% Internal node max length = 2
% Max tree depth in lits   = 3
% Max tree depth in nodes  = 3
% Max number of clauses    = 16

% On cycle #1, the best clause found is:
%      father(A, B) :- childof(B, A), male(B).  [covers 5,0/14,0 pos, 0,0/0,0 neg]
% This clause covers 5 positive examples, of which 5 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.

% ******************************************

%  Have stopped ILP's outer loop because the tree-structured queue is empty.

% ******************************************

%%%%%  WILL-Produced Tree #1 @ 14:10:39 10/20/22.  %%%%%


% FOR father(A, B):
%   if ( childof(B, A), male(B) )
%   then return 0.8581489350995122;  // std dev = 0,000, 5,000 (wgt'ed) examples reached here.  /* #pos=5 */
%   else return -0.1418510649004878;  // std dev = 0,000, 9,000 (wgt'ed) examples reached here.  /* #neg=9 */


% Clauses:

father(A, B, 0.8581489350995122) :- 
     childof(B, A), 
     male(B), 
     !. // Clause #1.

father(A, B, -0.1418510649004878) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.8581489350995122) :-  /* #pos=5 */ 
   childof(b, a),
   male(b),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.1418510649004878) :-  /* #neg=9 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)
%   male(b)

% Saving model in: data/toy_father/train/models/bRDNs/father.model.ckpt
% Time taken to learn 1 trees is 30 milliseconds.

%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.2295918367346937
Set score:0.0025
% Kept 5 of the 5 positive examples.
% Kept 3 of the 21 negative examples.
% Dataset size: 8
Computing probabilities
prob time:0 seconds
No hidden examples for : father
Time to build dataset: 1 milliseconds
%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.16731715135902567
Set score:0.0025

***** Warning: % Have only 8 positive examples, so cannot choose 10 of them. *****


% Have these 8 positive seeds: 0 1 2 3 4 5 6 7

% target           = father(A, B)
%     Score = -Infinity (regressionFit = Infinity, penalties=2.2E-7) for clause:  father(_, _).  [covers 8,0/8,0 pos, 0,0/0,0 neg]
% Most-general root: father(_, _).  [covers 8,0/8,0 pos, 0,0/0,0 neg]  score = -Infinity
%     Score = -Infinity (regressionFit = Infinity, penalties=1.12E-6) for clause:  father(A, _) :- male(A).  [covers 7,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.12E-6) for clause:  father(_, A) :- male(A).  [covers 7,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- childof(B, A).  [covers 6,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- siblingof(A, B).  [covers 1,0/8,0 pos, 0,0/0,0 neg]
%     Score = -1,249303 (regressionFit = 1,249301, penalties=1.23E-6) for clause:  father(A, _) :- siblingof(A, _).  [covers 4,0/8,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -1,249303): father(A, _) :- siblingof(A, _).  [covers 4,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- siblingof(B, A).  [covers 1,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.23E-6) for clause:  father(_, A) :- siblingof(A, _).  [covers 1,0/8,0 pos, 0,0/0,0 neg]
%     Score = -1,198870 (regressionFit = 1,198868, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- siblingof(A, _), male(A).  [covers 3,0/8,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -1,198870): father(A, _) :- siblingof(A, _), male(A).  [covers 3,0/8,0 pos, 0,0/0,0 neg]
%     Score = -1,249304 (regressionFit = 1,249301, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), male(B).  [covers 4,0/8,0 pos, 0,0/0,0 neg]
%     Score = -1,192061 (regressionFit = 1,192059, penalties=2.1300000000000004E-6) for clause:  father(A, _) :- siblingof(A, B), male(B).  [covers 4,0/8,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -1,192061): father(A, _) :- siblingof(A, B), male(B).  [covers 4,0/8,0 pos, 0,0/0,0 neg]
%     Score = -1,031811 (regressionFit = 1,031809, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), childof(B, A).  [covers 3,0/8,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -1,031811): father(A, B) :- siblingof(A, _), childof(B, A).  [covers 3,0/8,0 pos, 0,0/0,0 neg]
%     Score = -1,031811 (regressionFit = 1,031809, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, C), childof(B, C).  [covers 3,0/8,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -1,031811): father(A, B) :- siblingof(A, C), childof(B, C).  [covers 3,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(A, B).  [covers 1,0/8,0 pos, 0,0/0,0 neg]
%     Score = -1,249304 (regressionFit = 1,249301, penalties=2.24E-6) for clause:  father(A, _) :- siblingof(A, _), siblingof(A, _).  [covers 4,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(B, A).  [covers 1,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(A, C), siblingof(B, C).  [covers 1,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.1400000000000003E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(B, _).  [covers 1,0/8,0 pos, 0,0/0,0 neg]
%     Score = -1,249303 (regressionFit = 1,249301, penalties=2.0300000000000005E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, A).  [covers 4,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(A, C), siblingof(C, B).  [covers 1,0/8,0 pos, 0,0/0,0 neg]
%     Score = -1,249304 (regressionFit = 1,249301, penalties=2.1400000000000003E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, _).  [covers 4,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(A), male(B).  [covers 6,0/8,0 pos, 0,0/0,0 neg]
%     Score = -1,047036 (regressionFit = 1,047034, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), childof(B, A).  [covers 5,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), siblingof(A, B).  [covers 1,0/8,0 pos, 0,0/0,0 neg]
%     Score = -1,332590 (regressionFit = 1,332588, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- male(A), siblingof(A, _).  [covers 3,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), siblingof(B, A).  [covers 1,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(A), siblingof(B, _).  [covers 1,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(B), male(A).  [covers 6,0/8,0 pos, 0,0/0,0 neg]
%     Score = -0,000002 (regressionFit = 0,000000, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), childof(B, A).  [covers 5,0/8,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,000002): father(A, B) :- male(B), childof(B, A).  [covers 5,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), siblingof(A, B).  [covers 1,0/8,0 pos, 0,0/0,0 neg]
%     Score = -1,249304 (regressionFit = 1,249301, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(B), siblingof(A, _).  [covers 4,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), siblingof(B, A).  [covers 1,0/8,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.2300000000000002E-6) for clause:  father(_, A) :- male(A), siblingof(A, _).  [covers 1,0/8,0 pos, 0,0/0,0 neg]
%     Score = -1,047036 (regressionFit = 1,047034, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(A).  [covers 5,0/8,0 pos, 0,0/0,0 neg]
%     Score = -0,000002 (regressionFit = 0,000000, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(B).  [covers 5,0/8,0 pos, 0,0/0,0 neg]
%     Score = -0,856666 (regressionFit = 0,856664, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- childof(B, A), siblingof(A, _).  [covers 3,0/8,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- male(B), childof(B, A).  [covers 5,0/8,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- male(B), childof(B, A).  [covers 5,0/8,0 pos, 0,0/0,0 neg]

% Expanding node at Level 0 with score = 1,797693e+308.
% Will extend: father(A, B) :- male(B), childof(B, A).  [covers 5,0/8,0 pos, 0,0/0,0 neg]
Comparing variance: 0.0 to score=0.0025 #egs=5.0
Comparing variance: 0.0 to score=0.0025 #egs=3.0
%   Creating a TRUE-branch leaf because wgtedCountTrueBranchPos = 5,0 < 2.1 * minPosCov = 6,3
%   Creating a FALSE-branch leaf because wgtedCountFalseBranchPos = 3,0 < 2.1 * minPosCov = 6,3

% Time for loop #1: 22 milliseconds.
% Internal node max length = 2
% Max tree depth in lits   = 3
% Max tree depth in nodes  = 3
% Max number of clauses    = 16

% On cycle #1, the best clause found is:
%      father(A, B) :- male(B), childof(B, A).  [covers 5,0/8,0 pos, 0,0/0,0 neg]
% This clause covers 5 positive examples, of which 5 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.

% ******************************************

%  Have stopped ILP's outer loop because the tree-structured queue is empty.

% ******************************************

%%%%%  WILL-Produced Tree #2 @ 14:10:39 10/20/22.  %%%%%


% FOR father(A, B):
%   if ( male(B), childof(B, A) )
%   then return 0.7194734122109545;  // std dev = 0,000, 5,000 (wgt'ed) examples reached here.  /* #pos=5 */
%   else return -0.12544463852839138;  // std dev = 0,000, 3,000 (wgt'ed) examples reached here.  /* #neg=3 */


% Clauses:

father(A, B, 0.7194734122109545) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.12544463852839138) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.7194734122109545) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.12544463852839138) :-  /* #neg=3 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)
%   male(b)

% Saving model in: data/toy_father/train/models/bRDNs/father.model.ckpt
% Time taken to learn 2 trees is 59 milliseconds.

%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.16731715135902567
Set score:0.0025
% Kept 5 of the 5 positive examples.
% Kept 10 of the 21 negative examples.
% Dataset size: 15
Computing probabilities
prob time:2 milliseconds
No hidden examples for : father
Time to build dataset: 2 milliseconds
%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.09906674252579038
Set score:0.0025

% Have these 6 positive seeds: 0 1 3 8 11 13

% target           = father(A, B)
%     Score = -Infinity (regressionFit = Infinity, penalties=2.2E-7) for clause:  father(_, _).  [covers 15,0/15,0 pos, 0,0/0,0 neg]
% Most-general root: father(_, _).  [covers 15,0/15,0 pos, 0,0/0,0 neg]  score = -Infinity
%     Score = -1,426562 (regressionFit = 1,426561, penalties=1.12E-6) for clause:  father(A, _) :- male(A).  [covers 10,0/15,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -1,426562): father(A, _) :- male(A).  [covers 10,0/15,0 pos, 0,0/0,0 neg]
%     Score = -1,114502 (regressionFit = 1,114501, penalties=1.12E-6) for clause:  father(_, A) :- male(A).  [covers 10,0/15,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -1,114502): father(_, A) :- male(A).  [covers 10,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,636859 (regressionFit = 0,636858, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- childof(B, A).  [covers 7,0/15,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,636859): father(A, B) :- childof(B, A).  [covers 7,0/15,0 pos, 0,0/0,0 neg]
%     Score = -1,432931 (regressionFit = 1,432930, penalties=1.23E-6) for clause:  father(A, _) :- siblingof(A, _).  [covers 7,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,405275 (regressionFit = 0,405273, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(A).  [covers 4,0/15,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,405275): father(A, B) :- childof(B, A), male(A).  [covers 4,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,000002 (regressionFit = 0,000000, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,000002): father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
%     Score = -1,063844 (regressionFit = 1,063842, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- childof(B, A), siblingof(A, _).  [covers 4,0/15,0 pos, 0,0/0,0 neg]
%     Score = -1,273717 (regressionFit = 1,273715, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(B), male(A).  [covers 8,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,000002 (regressionFit = 0,000000, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), childof(B, A).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
%     Score = -1,248243 (regressionFit = 1,248241, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(B), siblingof(A, _).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
%     Score = -1,273717 (regressionFit = 1,273715, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(A), male(B).  [covers 8,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,405275 (regressionFit = 0,405273, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), childof(B, A).  [covers 4,0/15,0 pos, 0,0/0,0 neg]
%     Score = -1,471143 (regressionFit = 1,471141, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- male(A), siblingof(A, _).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
%     Score = -1,428613 (regressionFit = 1,428611, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- siblingof(A, _), male(A).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
%     Score = -1,250585 (regressionFit = 1,250582, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
%     Score = -1,426682 (regressionFit = 1,426680, penalties=2.1300000000000004E-6) for clause:  father(A, _) :- siblingof(A, B), male(B).  [covers 7,0/15,0 pos, 0,0/0,0 neg]
%     Score = -1,055337 (regressionFit = 1,055335, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), childof(B, A).  [covers 4,0/15,0 pos, 0,0/0,0 neg]
%     Score = -1,055337 (regressionFit = 1,055335, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, C), childof(B, C).  [covers 4,0/15,0 pos, 0,0/0,0 neg]
%     Score = -1,432932 (regressionFit = 1,432930, penalties=2.24E-6) for clause:  father(A, _) :- siblingof(A, _), siblingof(A, _).  [covers 7,0/15,0 pos, 0,0/0,0 neg]
%     Score = -1,432932 (regressionFit = 1,432930, penalties=2.0300000000000005E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, A).  [covers 7,0/15,0 pos, 0,0/0,0 neg]
%     Score = -1,432932 (regressionFit = 1,432930, penalties=2.1400000000000003E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, _).  [covers 7,0/15,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]

% Expanding node at Level 0 with score = 1,797693e+308.
% Will extend: father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
Comparing variance: -4.4408920985006264E-17 to score=0.0025 #egs=5.0
Comparing variance: 0.0 to score=0.0025 #egs=10.0
%   Creating a TRUE-branch leaf because wgtedCountTrueBranchPos = 5,0 < 2.1 * minPosCov = 6,3
%   Creating a FALSE-branch leaf because good enough fit since score < 0.0025

% Time for loop #1: 20 milliseconds.
% Internal node max length = 2
% Max tree depth in lits   = 3
% Max tree depth in nodes  = 3
% Max number of clauses    = 16

% On cycle #1, the best clause found is:
%      father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
% This clause covers 5 positive examples, of which 5 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.

% ******************************************

%  Have stopped ILP's outer loop because the tree-structured queue is empty.

% ******************************************

%%%%%  WILL-Produced Tree #3 @ 14:10:39 10/20/22.  %%%%%


% FOR father(A, B):
%   if ( childof(B, A), male(B) )
%   then return 0.5553664367462845;  // std dev = 0,000, 5,000 (wgt'ed) examples reached here.  /* #pos=5 */
%   else return -0.11231637819360638;  // std dev = 0,000, 10,000 (wgt'ed) examples reached here.  /* #neg=10 */


% Clauses:

father(A, B, 0.5553664367462845) :- 
     childof(B, A), 
     male(B), 
     !. // Clause #1.

father(A, B, -0.11231637819360638) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.5553664367462845) :-  /* #pos=5 */ 
   childof(b, a),
   male(b),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.11231637819360638) :-  /* #neg=10 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)
%   male(b)

% Saving model in: data/toy_father/train/models/bRDNs/father.model.ckpt
% Time taken to learn 3 trees is 87 milliseconds.

%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.09906674252579038
Set score:0.0025
% Kept 5 of the 5 positive examples.
% Kept 9 of the 21 negative examples.
% Dataset size: 14
Computing probabilities
prob time:2 milliseconds
No hidden examples for : father
Time to build dataset: 2 milliseconds
%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.06186928372478025
Set score:0.0025

% Have these 5 positive seeds: 0 2 8 12 13

% target           = father(A, B)
%     Score = -Infinity (regressionFit = Infinity, penalties=2.2E-7) for clause:  father(_, _).  [covers 14,0/14,0 pos, 0,0/0,0 neg]
% Most-general root: father(_, _).  [covers 14,0/14,0 pos, 0,0/0,0 neg]  score = -Infinity
%     Score = -0,848848 (regressionFit = 0,848847, penalties=1.12E-6) for clause:  father(A, _) :- male(A).  [covers 10,0/14,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,848848): father(A, _) :- male(A).  [covers 10,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,734933 (regressionFit = 0,734932, penalties=1.12E-6) for clause:  father(_, A) :- male(A).  [covers 11,0/14,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,734933): father(_, A) :- male(A).  [covers 11,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,224564 (regressionFit = 0,224563, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- childof(B, A).  [covers 6,0/14,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,224564): father(A, B) :- childof(B, A).  [covers 6,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- siblingof(A, B).  [covers 2,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,846923 (regressionFit = 0,846922, penalties=1.23E-6) for clause:  father(A, _) :- siblingof(A, _).  [covers 7,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- siblingof(B, A).  [covers 2,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.23E-6) for clause:  father(_, A) :- siblingof(A, _).  [covers 2,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,242530 (regressionFit = 0,242528, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(A).  [covers 4,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,000002 (regressionFit = 2,49800e-16, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(B).  [covers 5,0/14,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,000002): father(A, B) :- childof(B, A), male(B).  [covers 5,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,633269 (regressionFit = 0,633266, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- childof(B, A), siblingof(A, _).  [covers 4,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,814416 (regressionFit = 0,814414, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(B), male(A).  [covers 9,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,000002 (regressionFit = 2,22045e-16, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), childof(B, A).  [covers 5,0/14,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,000002): father(A, B) :- male(B), childof(B, A).  [covers 5,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), siblingof(A, B).  [covers 2,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,808427 (regressionFit = 0,808425, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(B), siblingof(A, _).  [covers 6,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), siblingof(B, A).  [covers 2,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.2300000000000002E-6) for clause:  father(_, A) :- male(A), siblingof(A, _).  [covers 2,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,843252 (regressionFit = 0,843249, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- siblingof(A, _), male(A).  [covers 5,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,814750 (regressionFit = 0,814748, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), male(B).  [covers 6,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,843076 (regressionFit = 0,843073, penalties=2.1300000000000004E-6) for clause:  father(A, _) :- siblingof(A, B), male(B).  [covers 7,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,623173 (regressionFit = 0,623171, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), childof(B, A).  [covers 4,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,623173 (regressionFit = 0,623171, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, C), childof(B, C).  [covers 4,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(A, B).  [covers 2,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,846924 (regressionFit = 0,846922, penalties=2.24E-6) for clause:  father(A, _) :- siblingof(A, _), siblingof(A, _).  [covers 7,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(B, A).  [covers 2,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(A, C), siblingof(B, C).  [covers 2,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.1400000000000003E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(B, _).  [covers 2,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,846924 (regressionFit = 0,846922, penalties=2.0300000000000005E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, A).  [covers 7,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(A, C), siblingof(C, B).  [covers 2,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,846924 (regressionFit = 0,846922, penalties=2.1400000000000003E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, _).  [covers 7,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,814416 (regressionFit = 0,814414, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(A), male(B).  [covers 9,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,242530 (regressionFit = 0,242528, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), childof(B, A).  [covers 4,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), siblingof(A, B).  [covers 2,0/14,0 pos, 0,0/0,0 neg]
%     Score = -0,862323 (regressionFit = 0,862320, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- male(A), siblingof(A, _).  [covers 5,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), siblingof(B, A).  [covers 2,0/14,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(A), siblingof(B, _).  [covers 2,0/14,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- male(B), childof(B, A).  [covers 5,0/14,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- male(B), childof(B, A).  [covers 5,0/14,0 pos, 0,0/0,0 neg]

% Expanding node at Level 0 with score = 1,797693e+308.
% Will extend: father(A, B) :- male(B), childof(B, A).  [covers 5,0/14,0 pos, 0,0/0,0 neg]
Comparing variance: 4.4408920985006264E-17 to score=0.0025 #egs=5.0
Comparing variance: 0.0 to score=0.0025 #egs=9.0
%   Creating a TRUE-branch leaf because wgtedCountTrueBranchPos = 5,0 < 2.1 * minPosCov = 6,3
%   Creating a FALSE-branch leaf because good enough fit since score < 0.0025

% Time for loop #1: 22 milliseconds.
% Internal node max length = 2
% Max tree depth in lits   = 3
% Max tree depth in nodes  = 3
% Max number of clauses    = 16

% On cycle #1, the best clause found is:
%      father(A, B) :- male(B), childof(B, A).  [covers 5,0/14,0 pos, 0,0/0,0 neg]
% This clause covers 5 positive examples, of which 5 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.

% ******************************************

%  Have stopped ILP's outer loop because the tree-structured queue is empty.

% ******************************************

%%%%%  WILL-Produced Tree #4 @ 14:10:39 10/20/22.  %%%%%


% FOR father(A, B):
%   if ( male(B), childof(B, A) )
%   then return 0.4175135841583099;  // std dev = 1,49e-08, 5,000 (wgt'ed) examples reached here.  /* #pos=5 */
%   else return -0.10159632948783628;  // std dev = 0,000, 9,000 (wgt'ed) examples reached here.  /* #neg=9 */


% Clauses:

father(A, B, 0.4175135841583099) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.10159632948783628) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.4175135841583099) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.10159632948783628) :-  /* #neg=9 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)
%   male(b)

% Saving model in: data/toy_father/train/models/bRDNs/father.model.ckpt
% Time taken to learn 4 trees is 118 milliseconds.

%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.06186928372478025
Set score:0.0025
% Kept 5 of the 5 positive examples.
% Kept 12 of the 21 negative examples.
% Dataset size: 17
Computing probabilities
prob time:3 milliseconds
No hidden examples for : father
Time to build dataset: 3 milliseconds
%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.03548141364603075
Set score:0.0025

% Have these 8 positive seeds: 1 3 6 7 8 10 13 14

% target           = father(A, B)
%     Score = -Infinity (regressionFit = Infinity, penalties=2.2E-7) for clause:  father(_, _).  [covers 17,0/17,0 pos, 0,0/0,0 neg]
% Most-general root: father(_, _).  [covers 17,0/17,0 pos, 0,0/0,0 neg]  score = -Infinity
%     Score = -0,592462 (regressionFit = 0,592461, penalties=1.12E-6) for clause:  father(A, _) :- male(A).  [covers 12,0/17,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,592462): father(A, _) :- male(A).  [covers 12,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,498466 (regressionFit = 0,498465, penalties=1.12E-6) for clause:  father(_, A) :- male(A).  [covers 12,0/17,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,498466): father(_, A) :- male(A).  [covers 12,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,142419 (regressionFit = 0,142418, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- childof(B, A).  [covers 6,0/17,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,142419): father(A, B) :- childof(B, A).  [covers 6,0/17,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- siblingof(A, B).  [covers 2,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,586291 (regressionFit = 0,586289, penalties=1.23E-6) for clause:  father(A, _) :- siblingof(A, _).  [covers 8,0/17,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- siblingof(B, A).  [covers 2,0/17,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.23E-6) for clause:  father(_, A) :- siblingof(A, _).  [covers 2,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,157758 (regressionFit = 0,157756, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(A).  [covers 4,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,000002 (regressionFit = 2,77556e-17, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(B).  [covers 5,0/17,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,000002): father(A, B) :- childof(B, A), male(B).  [covers 5,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,292977 (regressionFit = 0,292975, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- childof(B, A), siblingof(A, _).  [covers 3,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,529324 (regressionFit = 0,529322, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(B), male(A).  [covers 9,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,000002 (regressionFit = 1,38778e-17, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), childof(B, A).  [covers 5,0/17,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,000002): father(A, B) :- male(B), childof(B, A).  [covers 5,0/17,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), siblingof(A, B).  [covers 2,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,536013 (regressionFit = 0,536011, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(B), siblingof(A, _).  [covers 6,0/17,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), siblingof(B, A).  [covers 2,0/17,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.2300000000000002E-6) for clause:  father(_, A) :- male(A), siblingof(A, _).  [covers 2,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,588216 (regressionFit = 0,588214, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- siblingof(A, _), male(A).  [covers 6,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,527629 (regressionFit = 0,527627, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), male(B).  [covers 6,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,581625 (regressionFit = 0,581623, penalties=2.1300000000000004E-6) for clause:  father(A, _) :- siblingof(A, B), male(B).  [covers 8,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,272633 (regressionFit = 0,272631, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), childof(B, A).  [covers 3,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,272633 (regressionFit = 0,272631, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, C), childof(B, C).  [covers 3,0/17,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(A, B).  [covers 2,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,586292 (regressionFit = 0,586289, penalties=2.24E-6) for clause:  father(A, _) :- siblingof(A, _), siblingof(A, _).  [covers 8,0/17,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(B, A).  [covers 2,0/17,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(A, C), siblingof(B, C).  [covers 2,0/17,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.1400000000000003E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(B, _).  [covers 2,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,586291 (regressionFit = 0,586289, penalties=2.0300000000000005E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, A).  [covers 8,0/17,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(A, C), siblingof(C, B).  [covers 2,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,586291 (regressionFit = 0,586289, penalties=2.1400000000000003E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, _).  [covers 8,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,529324 (regressionFit = 0,529322, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(A), male(B).  [covers 9,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,157758 (regressionFit = 0,157756, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), childof(B, A).  [covers 4,0/17,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), siblingof(A, B).  [covers 2,0/17,0 pos, 0,0/0,0 neg]
%     Score = -0,600749 (regressionFit = 0,600747, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- male(A), siblingof(A, _).  [covers 6,0/17,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), siblingof(B, A).  [covers 2,0/17,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(A), siblingof(B, _).  [covers 2,0/17,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- male(B), childof(B, A).  [covers 5,0/17,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- male(B), childof(B, A).  [covers 5,0/17,0 pos, 0,0/0,0 neg]

% Expanding node at Level 0 with score = 1,797693e+308.
% Will extend: father(A, B) :- male(B), childof(B, A).  [covers 5,0/17,0 pos, 0,0/0,0 neg]
Comparing variance: -2.2204460492503132E-17 to score=0.0025 #egs=5.0
Comparing variance: 1.1564823173178713E-18 to score=0.0025 #egs=12.0
%   Creating a TRUE-branch leaf because wgtedCountTrueBranchPos = 5,0 < 2.1 * minPosCov = 6,3
%   Creating a FALSE-branch leaf because good enough fit since score < 0.0025

% Time for loop #1: 37 milliseconds.
% Internal node max length = 2
% Max tree depth in lits   = 3
% Max tree depth in nodes  = 3
% Max number of clauses    = 16

% On cycle #1, the best clause found is:
%      father(A, B) :- male(B), childof(B, A).  [covers 5,0/17,0 pos, 0,0/0,0 neg]
% This clause covers 5 positive examples, of which 5 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.

% ******************************************

%  Have stopped ILP's outer loop because the tree-structured queue is empty.

% ******************************************

%%%%%  WILL-Produced Tree #5 @ 14:10:39 10/20/22.  %%%%%


% FOR father(A, B):
%   if ( male(B), childof(B, A) )
%   then return 0.32071184716014967;  // std dev = 0,000, 5,000 (wgt'ed) examples reached here.  /* #pos=5 */
%   else return -0.09269127618926097;  // std dev = 3,73e-09, 12,000 (wgt'ed) examples reached here.  /* #neg=12 */


% Clauses:

father(A, B, 0.32071184716014967) :- 
     male(B), 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.09269127618926097) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.32071184716014967) :-  /* #pos=5 */ 
   male(b),
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.09269127618926097) :-  /* #neg=12 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)
%   male(b)

% Saving model in: data/toy_father/train/models/bRDNs/father.model.ckpt
% Time taken to learn 5 trees is 164 milliseconds.

%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.03548141364603075
Set score:0.0025
% Kept 5 of the 5 positive examples.
% Kept 10 of the 21 negative examples.
% Dataset size: 15
Computing probabilities
prob time:3 milliseconds
No hidden examples for : father
Time to build dataset: 3 milliseconds
%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.025742862963566353
Set score:0.0025

% Have these 8 positive seeds: 1 2 4 5 7 8 9 10

% target           = father(A, B)
%     Score = -Infinity (regressionFit = Infinity, penalties=2.2E-7) for clause:  father(_, _).  [covers 15,0/15,0 pos, 0,0/0,0 neg]
% Most-general root: father(_, _).  [covers 15,0/15,0 pos, 0,0/0,0 neg]  score = -Infinity
%     Score = -0,381756 (regressionFit = 0,381755, penalties=1.12E-6) for clause:  father(A, _) :- male(A).  [covers 11,0/15,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,381756): father(A, _) :- male(A).  [covers 11,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,315936 (regressionFit = 0,315935, penalties=1.12E-6) for clause:  father(_, A) :- male(A).  [covers 11,0/15,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,315936): father(_, A) :- male(A).  [covers 11,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,165491 (regressionFit = 0,165490, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- childof(B, A).  [covers 7,0/15,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,165491): father(A, B) :- childof(B, A).  [covers 7,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337876 (regressionFit = 0,337875, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- siblingof(A, B).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,382696 (regressionFit = 0,382695, penalties=1.23E-6) for clause:  father(A, _) :- siblingof(A, _).  [covers 8,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337876 (regressionFit = 0,337875, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- siblingof(B, A).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337876 (regressionFit = 0,337875, penalties=1.23E-6) for clause:  father(_, A) :- siblingof(A, _).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,196935 (regressionFit = 0,196933, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(A).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,000002 (regressionFit = 0,000000, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,000002): father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,193074 (regressionFit = 0,193071, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- childof(B, A), siblingof(A, _).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,353966 (regressionFit = 0,353964, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(B), male(A).  [covers 9,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,000002 (regressionFit = 0,000000, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), childof(B, A).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), siblingof(A, B).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,372354 (regressionFit = 0,372352, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(B), siblingof(A, _).  [covers 7,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), siblingof(B, A).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.2300000000000002E-6) for clause:  father(_, A) :- male(A), siblingof(A, _).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- siblingof(A, B), male(A).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- siblingof(A, B), male(B).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, B), siblingof(A, _).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- siblingof(A, B), siblingof(B, A).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, B), siblingof(B, _).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- siblingof(B, A), male(A).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- siblingof(B, A), male(B).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- siblingof(B, A), siblingof(A, B).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(B, A), siblingof(A, _).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(B, A), siblingof(B, _).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(B, _), male(A).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.2300000000000002E-6) for clause:  father(_, A) :- siblingof(A, _), male(A).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.1300000000000004E-6) for clause:  father(_, A) :- siblingof(A, B), male(B).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(B, _), siblingof(A, B).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(B, C), siblingof(A, C).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.1400000000000003E-6) for clause:  father(A, B) :- siblingof(B, _), siblingof(A, _).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(B, _), siblingof(B, A).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.24E-6) for clause:  father(_, A) :- siblingof(A, _), siblingof(A, _).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(B, C), siblingof(C, A).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.0300000000000005E-6) for clause:  father(_, A) :- siblingof(A, B), siblingof(B, A).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.1400000000000003E-6) for clause:  father(_, A) :- siblingof(A, B), siblingof(B, _).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,353966 (regressionFit = 0,353964, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(A), male(B).  [covers 9,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,196935 (regressionFit = 0,196933, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), childof(B, A).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), siblingof(A, B).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,382697 (regressionFit = 0,382695, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- male(A), siblingof(A, _).  [covers 7,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), siblingof(B, A).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,337877 (regressionFit = 0,337875, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(A), siblingof(B, _).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,351963 (regressionFit = 0,351961, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- siblingof(A, _), male(A).  [covers 7,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,370524 (regressionFit = 0,370522, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), male(B).  [covers 7,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,373518 (regressionFit = 0,373515, penalties=2.1300000000000004E-6) for clause:  father(A, _) :- siblingof(A, B), male(B).  [covers 8,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,175406 (regressionFit = 0,175404, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), childof(B, A).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,175406 (regressionFit = 0,175404, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, C), childof(B, C).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,309123 (regressionFit = 0,309121, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(A, B).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,382697 (regressionFit = 0,382695, penalties=2.24E-6) for clause:  father(A, _) :- siblingof(A, _), siblingof(A, _).  [covers 8,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,309123 (regressionFit = 0,309121, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(B, A).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,309123 (regressionFit = 0,309121, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(A, C), siblingof(B, C).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,309123 (regressionFit = 0,309121, penalties=2.1400000000000003E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(B, _).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,382697 (regressionFit = 0,382695, penalties=2.0300000000000005E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, A).  [covers 8,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,309123 (regressionFit = 0,309121, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(A, C), siblingof(C, B).  [covers 3,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,382697 (regressionFit = 0,382695, penalties=2.1400000000000003E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, _).  [covers 8,0/15,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]

% Expanding node at Level 0 with score = 1,797693e+308.
% Will extend: father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
Comparing variance: 0.0 to score=0.0025 #egs=5.0
Comparing variance: 0.0 to score=0.0025 #egs=10.0
%   Creating a TRUE-branch leaf because wgtedCountTrueBranchPos = 5,0 < 2.1 * minPosCov = 6,3
%   Creating a FALSE-branch leaf because good enough fit since score < 0.0025

% Time for loop #1: 50 milliseconds.
% Internal node max length = 2
% Max tree depth in lits   = 3
% Max tree depth in nodes  = 3
% Max number of clauses    = 16

% On cycle #1, the best clause found is:
%      father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
% This clause covers 5 positive examples, of which 5 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.

% ******************************************

%  Have stopped ILP's outer loop because the tree-structured queue is empty.

% ******************************************

%%%%%  WILL-Produced Tree #6 @ 14:10:39 10/20/22.  %%%%%


% FOR father(A, B):
%   if ( childof(B, A), male(B) )
%   then return 0.25517224256948945;  // std dev = 0,000, 5,000 (wgt'ed) examples reached here.  /* #pos=5 */
%   else return -0.08518475138839687;  // std dev = 0,000, 10,000 (wgt'ed) examples reached here.  /* #neg=10 */


% Clauses:

father(A, B, 0.25517224256948945) :- 
     childof(B, A), 
     male(B), 
     !. // Clause #1.

father(A, B, -0.08518475138839687) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.25517224256948945) :-  /* #pos=5 */ 
   childof(b, a),
   male(b),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.08518475138839687) :-  /* #neg=10 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)
%   male(b)

% Saving model in: data/toy_father/train/models/bRDNs/father.model.ckpt
% Time taken to learn 6 trees is 224 milliseconds.

%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.025742862963566353
Set score:0.0025
% Kept 5 of the 5 positive examples.
% Kept 7 of the 21 negative examples.
% Dataset size: 12
Computing probabilities
prob time:2 milliseconds
No hidden examples for : father
Time to build dataset: 3 milliseconds
%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.02023489528181015
Set score:0.0025

% Have these 8 positive seeds: 1 2 3 4 6 7 10 11

% target           = father(A, B)
%     Score = -Infinity (regressionFit = Infinity, penalties=2.2E-7) for clause:  father(_, _).  [covers 12,0/12,0 pos, 0,0/0,0 neg]
% Most-general root: father(_, _).  [covers 12,0/12,0 pos, 0,0/0,0 neg]  score = -Infinity
%     Score = -0,228945 (regressionFit = 0,228943, penalties=1.12E-6) for clause:  father(A, _) :- male(A).  [covers 8,0/12,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,228945): father(A, _) :- male(A).  [covers 8,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,185006 (regressionFit = 0,185005, penalties=1.12E-6) for clause:  father(_, A) :- male(A).  [covers 9,0/12,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,185006): father(_, A) :- male(A).  [covers 9,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,069378 (regressionFit = 0,069377, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- childof(B, A).  [covers 6,0/12,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,069378): father(A, B) :- childof(B, A).  [covers 6,0/12,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- siblingof(A, B).  [covers 1,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,187319 (regressionFit = 0,187317, penalties=1.23E-6) for clause:  father(A, _) :- siblingof(A, _).  [covers 4,0/12,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- siblingof(B, A).  [covers 1,0/12,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.23E-6) for clause:  father(_, A) :- siblingof(A, _).  [covers 1,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,137963 (regressionFit = 0,137961, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(A).  [covers 5,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,000002 (regressionFit = 0,000000, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(B).  [covers 5,0/12,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,000002): father(A, B) :- childof(B, A), male(B).  [covers 5,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,129505 (regressionFit = 0,129503, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- childof(B, A), siblingof(A, _).  [covers 3,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,209322 (regressionFit = 0,209320, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(B), male(A).  [covers 7,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,000002 (regressionFit = 0,000000, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), childof(B, A).  [covers 5,0/12,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), siblingof(A, B).  [covers 1,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,187319 (regressionFit = 0,187317, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(B), siblingof(A, _).  [covers 4,0/12,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), siblingof(B, A).  [covers 1,0/12,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.2300000000000002E-6) for clause:  father(_, A) :- male(A), siblingof(A, _).  [covers 1,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,205208 (regressionFit = 0,205206, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- siblingof(A, _), male(A).  [covers 3,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,187319 (regressionFit = 0,187317, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), male(B).  [covers 4,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,181268 (regressionFit = 0,181266, penalties=2.1300000000000004E-6) for clause:  father(A, _) :- siblingof(A, B), male(B).  [covers 4,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,126510 (regressionFit = 0,126508, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), childof(B, A).  [covers 3,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,126510 (regressionFit = 0,126508, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, C), childof(B, C).  [covers 3,0/12,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(A, B).  [covers 1,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,187320 (regressionFit = 0,187317, penalties=2.24E-6) for clause:  father(A, _) :- siblingof(A, _), siblingof(A, _).  [covers 4,0/12,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(B, A).  [covers 1,0/12,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(A, C), siblingof(B, C).  [covers 1,0/12,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.1400000000000003E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(B, _).  [covers 1,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,187319 (regressionFit = 0,187317, penalties=2.0300000000000005E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, A).  [covers 4,0/12,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(A, C), siblingof(C, B).  [covers 1,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,187319 (regressionFit = 0,187317, penalties=2.1400000000000003E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, _).  [covers 4,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,209322 (regressionFit = 0,209320, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(A), male(B).  [covers 7,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,137963 (regressionFit = 0,137961, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), childof(B, A).  [covers 5,0/12,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), siblingof(A, B).  [covers 1,0/12,0 pos, 0,0/0,0 neg]
%     Score = -0,222008 (regressionFit = 0,222006, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- male(A), siblingof(A, _).  [covers 3,0/12,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), siblingof(B, A).  [covers 1,0/12,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(A), siblingof(B, _).  [covers 1,0/12,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- childof(B, A), male(B).  [covers 5,0/12,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- childof(B, A), male(B).  [covers 5,0/12,0 pos, 0,0/0,0 neg]

% Expanding node at Level 0 with score = 1,797693e+308.
% Will extend: father(A, B) :- childof(B, A), male(B).  [covers 5,0/12,0 pos, 0,0/0,0 neg]
Comparing variance: -5.551115123125783E-18 to score=0.0025 #egs=5.0
Comparing variance: -9.912705577010326E-19 to score=0.0025 #egs=7.0
%   Creating a TRUE-branch leaf because wgtedCountTrueBranchPos = 5,0 < 2.1 * minPosCov = 6,3
%   Creating a FALSE-branch leaf because good enough fit since score < 0.0025

% Time for loop #1: 25 milliseconds.
% Internal node max length = 2
% Max tree depth in lits   = 3
% Max tree depth in nodes  = 3
% Max number of clauses    = 16

% On cycle #1, the best clause found is:
%      father(A, B) :- childof(B, A), male(B).  [covers 5,0/12,0 pos, 0,0/0,0 neg]
% This clause covers 5 positive examples, of which 5 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.

% ******************************************

%  Have stopped ILP's outer loop because the tree-structured queue is empty.

% ******************************************

%%%%%  WILL-Produced Tree #7 @ 14:10:39 10/20/22.  %%%%%


% FOR father(A, B):
%   if ( childof(B, A), male(B) )
%   then return 0.20975771563253556;  // std dev = 0,000, 5,000 (wgt'ed) examples reached here.  /* #pos=5 */
%   else return -0.07877675473109173;  // std dev = 0,000, 7,000 (wgt'ed) examples reached here.  /* #neg=7 */


% Clauses:

father(A, B, 0.20975771563253556) :- 
     childof(B, A), 
     male(B), 
     !. // Clause #1.

father(A, B, -0.07877675473109173) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.20975771563253556) :-  /* #pos=5 */ 
   childof(b, a),
   male(b),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.07877675473109173) :-  /* #neg=7 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)
%   male(b)

% Saving model in: data/toy_father/train/models/bRDNs/father.model.ckpt
% Time taken to learn 7 trees is 259 milliseconds.

%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.02023489528181015
Set score:0.0025
% Kept 5 of the 5 positive examples.
% Kept 14 of the 21 negative examples.
% Dataset size: 19
Computing probabilities
prob time:4 milliseconds
No hidden examples for : father
Time to build dataset: 5 milliseconds
%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.012152364390470198
Set score:0.0025

% Have these 8 positive seeds: 3 5 6 9 10 11 15 17

% target           = father(A, B)
%     Score = -Infinity (regressionFit = Infinity, penalties=2.2E-7) for clause:  father(_, _).  [covers 19,0/19,0 pos, 0,0/0,0 neg]
% Most-general root: father(_, _).  [covers 19,0/19,0 pos, 0,0/0,0 neg]  score = -Infinity
%     Score = -0,229200 (regressionFit = 0,229199, penalties=1.12E-6) for clause:  father(A, _) :- male(A).  [covers 14,0/19,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,229200): father(A, _) :- male(A).  [covers 14,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,201445 (regressionFit = 0,201444, penalties=1.12E-6) for clause:  father(_, A) :- male(A).  [covers 14,0/19,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,201445): father(_, A) :- male(A).  [covers 14,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,000001 (regressionFit = 1,38778e-17, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- childof(B, A).  [covers 5,0/19,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,000001): father(A, B) :- childof(B, A).  [covers 5,0/19,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- siblingof(A, B).  [covers 2,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,220064 (regressionFit = 0,220062, penalties=1.23E-6) for clause:  father(A, _) :- siblingof(A, _).  [covers 8,0/19,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- siblingof(B, A).  [covers 2,0/19,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.23E-6) for clause:  father(_, A) :- siblingof(A, _).  [covers 2,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,058495 (regressionFit = 0,058493, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(A).  [covers 4,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,000002 (regressionFit = 1,38778e-17, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(B).  [covers 5,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,109677 (regressionFit = 0,109675, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- childof(B, A), siblingof(A, _).  [covers 3,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,214367 (regressionFit = 0,214365, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(B), male(A).  [covers 11,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,000002 (regressionFit = 1,38778e-17, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), childof(B, A).  [covers 5,0/19,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), siblingof(A, B).  [covers 2,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,200069 (regressionFit = 0,200067, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(B), siblingof(A, _).  [covers 6,0/19,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), siblingof(B, A).  [covers 2,0/19,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.2300000000000002E-6) for clause:  father(_, A) :- male(A), siblingof(A, _).  [covers 2,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,229348 (regressionFit = 0,229345, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- siblingof(A, _), male(A).  [covers 7,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,196638 (regressionFit = 0,196636, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), male(B).  [covers 6,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,216517 (regressionFit = 0,216515, penalties=2.1300000000000004E-6) for clause:  father(A, _) :- siblingof(A, B), male(B).  [covers 8,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,102653 (regressionFit = 0,102650, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), childof(B, A).  [covers 3,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,102652 (regressionFit = 0,102650, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, C), childof(B, C).  [covers 3,0/19,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(A, B).  [covers 2,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,220065 (regressionFit = 0,220062, penalties=2.24E-6) for clause:  father(A, _) :- siblingof(A, _), siblingof(A, _).  [covers 8,0/19,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(B, A).  [covers 2,0/19,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(A, C), siblingof(B, C).  [covers 2,0/19,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.1400000000000003E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(B, _).  [covers 2,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,220064 (regressionFit = 0,220062, penalties=2.0300000000000005E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, A).  [covers 8,0/19,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(A, C), siblingof(C, B).  [covers 2,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,220064 (regressionFit = 0,220062, penalties=2.1400000000000003E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, _).  [covers 8,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,214367 (regressionFit = 0,214365, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(A), male(B).  [covers 11,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,058495 (regressionFit = 0,058493, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), childof(B, A).  [covers 4,0/19,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), siblingof(A, B).  [covers 2,0/19,0 pos, 0,0/0,0 neg]
%     Score = -0,230544 (regressionFit = 0,230542, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- male(A), siblingof(A, _).  [covers 7,0/19,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), siblingof(B, A).  [covers 2,0/19,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(A), siblingof(B, _).  [covers 2,0/19,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- childof(B, A).  [covers 5,0/19,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- childof(B, A).  [covers 5,0/19,0 pos, 0,0/0,0 neg]

% Expanding node at Level 0 with score = 1,797693e+308.
% Will extend: father(A, B) :- childof(B, A).  [covers 5,0/19,0 pos, 0,0/0,0 neg]
Comparing variance: 0.0 to score=0.0025 #egs=5.0
Comparing variance: 9.912705577010326E-19 to score=0.0025 #egs=14.0
%   Creating a TRUE-branch leaf because wgtedCountTrueBranchPos = 5,0 < 2.1 * minPosCov = 6,3
%   Creating a FALSE-branch leaf because good enough fit since score < 0.0025

% Time for loop #1: 22 milliseconds.
% Internal node max length = 2
% Max tree depth in lits   = 3
% Max tree depth in nodes  = 3
% Max number of clauses    = 16

% On cycle #1, the best clause found is:
%      father(A, B) :- childof(B, A).  [covers 5,0/19,0 pos, 0,0/0,0 neg]
% This clause covers 5 positive examples, of which 5 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.

% ******************************************

%  Have stopped ILP's outer loop because the tree-structured queue is empty.

% ******************************************

%%%%%  WILL-Produced Tree #8 @ 14:10:39 10/20/22.  %%%%%


% FOR father(A, B):
%   if ( childof(B, A) )
%   then return 0.17709649774527736;  // std dev = 0,000, 5,000 (wgt'ed) examples reached here.  /* #pos=5 */
%   else return -0.07324622576333704;  // std dev = 3,73e-09, 14,000 (wgt'ed) examples reached here.  /* #neg=14 */


% Clauses:

father(A, B, 0.17709649774527736) :- 
     childof(B, A), 
     !. // Clause #1.

father(A, B, -0.07324622576333704) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.17709649774527736) :-  /* #pos=5 */ 
   childof(b, a),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.07324622576333704) :-  /* #neg=14 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)

% Saving model in: data/toy_father/train/models/bRDNs/father.model.ckpt
% Time taken to learn 8 trees is 293 milliseconds.

%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.012152364390470198
Set score:0.0025
% Kept 5 of the 5 positive examples.
% Kept 11 of the 21 negative examples.
% Dataset size: 16
Computing probabilities
prob time:4 milliseconds
No hidden examples for : father
Time to build dataset: 5 milliseconds
%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.010851356473370124
Set score:0.0025

% Have these 7 positive seeds: 1 4 7 8 10 11 15

% target           = father(A, B)
%     Score = -Infinity (regressionFit = Infinity, penalties=2.2E-7) for clause:  father(_, _).  [covers 16,0/16,0 pos, 0,0/0,0 neg]
% Most-general root: father(_, _).  [covers 16,0/16,0 pos, 0,0/0,0 neg]  score = -Infinity
%     Score = -0,153333 (regressionFit = 0,153332, penalties=1.12E-6) for clause:  father(A, _) :- male(A).  [covers 9,0/16,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,153333): father(A, _) :- male(A).  [covers 9,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,122714 (regressionFit = 0,122713, penalties=1.12E-6) for clause:  father(_, A) :- male(A).  [covers 10,0/16,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,122714): father(_, A) :- male(A).  [covers 10,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,081574 (regressionFit = 0,081573, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- childof(B, A).  [covers 7,0/16,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,081574): father(A, B) :- childof(B, A).  [covers 7,0/16,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- siblingof(A, B).  [covers 2,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,173138 (regressionFit = 0,173137, penalties=1.23E-6) for clause:  father(A, _) :- siblingof(A, _).  [covers 9,0/16,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- siblingof(B, A).  [covers 2,0/16,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.23E-6) for clause:  father(_, A) :- siblingof(A, _).  [covers 2,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,046681 (regressionFit = 0,046679, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(A).  [covers 4,0/16,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,046681): father(A, B) :- childof(B, A), male(A).  [covers 4,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,000520 (regressionFit = 0,000518, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(B).  [covers 5,0/16,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,000520): father(A, B) :- childof(B, A), male(B).  [covers 5,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,125957 (regressionFit = 0,125955, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- childof(B, A), siblingof(A, _).  [covers 4,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,129581 (regressionFit = 0,129579, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(B), male(A).  [covers 7,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,000520 (regressionFit = 0,000518, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), childof(B, A).  [covers 5,0/16,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), siblingof(A, B).  [covers 2,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,163940 (regressionFit = 0,163938, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(B), siblingof(A, _).  [covers 7,0/16,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), siblingof(B, A).  [covers 2,0/16,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.2300000000000002E-6) for clause:  father(_, A) :- male(A), siblingof(A, _).  [covers 2,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,129581 (regressionFit = 0,129579, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(A), male(B).  [covers 7,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,046681 (regressionFit = 0,046679, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), childof(B, A).  [covers 4,0/16,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), siblingof(A, B).  [covers 2,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,173176 (regressionFit = 0,173174, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- male(A), siblingof(A, _).  [covers 6,0/16,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), siblingof(B, A).  [covers 2,0/16,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(A), siblingof(B, _).  [covers 2,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,173387 (regressionFit = 0,173385, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- siblingof(A, _), male(A).  [covers 6,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,158050 (regressionFit = 0,158047, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), male(B).  [covers 7,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,173173 (regressionFit = 0,173170, penalties=2.1300000000000004E-6) for clause:  father(A, _) :- siblingof(A, B), male(B).  [covers 9,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,116597 (regressionFit = 0,116594, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), childof(B, A).  [covers 4,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,116597 (regressionFit = 0,116594, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, C), childof(B, C).  [covers 4,0/16,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(A, B).  [covers 2,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,173139 (regressionFit = 0,173137, penalties=2.24E-6) for clause:  father(A, _) :- siblingof(A, _), siblingof(A, _).  [covers 9,0/16,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(B, A).  [covers 2,0/16,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(A, C), siblingof(B, C).  [covers 2,0/16,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=2.1400000000000003E-6) for clause:  father(A, B) :- siblingof(A, _), siblingof(B, _).  [covers 2,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,173139 (regressionFit = 0,173137, penalties=2.0300000000000005E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, A).  [covers 9,0/16,0 pos, 0,0/0,0 neg]
%     Score = -Infinity (regressionFit = Infinity, penalties=1.93E-6) for clause:  father(A, B) :- siblingof(A, C), siblingof(C, B).  [covers 2,0/16,0 pos, 0,0/0,0 neg]
%     Score = -0,173139 (regressionFit = 0,173137, penalties=2.1400000000000003E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, _).  [covers 9,0/16,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- childof(B, A), male(B).  [covers 5,0/16,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- childof(B, A), male(B).  [covers 5,0/16,0 pos, 0,0/0,0 neg]

% Expanding node at Level 0 with score = 1,797693e+308.
% Will extend: father(A, B) :- childof(B, A), male(B).  [covers 5,0/16,0 pos, 0,0/0,0 neg]
Comparing variance: 0.0 to score=0.0025 #egs=5.0
Comparing variance: 4.706415871522727E-5 to score=0.0025 #egs=11.0
%   Creating a TRUE-branch leaf because wgtedCountTrueBranchPos = 5,0 < 2.1 * minPosCov = 6,3
%   Creating a FALSE-branch leaf because good enough fit since score < 0.0025

% Time for loop #1: 23 milliseconds.
% Internal node max length = 2
% Max tree depth in lits   = 3
% Max tree depth in nodes  = 3
% Max number of clauses    = 16

% On cycle #1, the best clause found is:
%      father(A, B) :- childof(B, A), male(B).  [covers 5,0/16,0 pos, 0,0/0,0 neg]
% This clause covers 5 positive examples, of which 5 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.

% ******************************************

%  Have stopped ILP's outer loop because the tree-structured queue is empty.

% ******************************************

%%%%%  WILL-Produced Tree #9 @ 14:10:39 10/20/22.  %%%%%


% FOR father(A, B):
%   if ( childof(B, A), male(B) )
%   then return 0.15274385809367097;  // std dev = 0,000, 5,000 (wgt'ed) examples reached here.  /* #pos=5 */
%   else return -0.0716609694856139;  // std dev = 0,023, 11,000 (wgt'ed) examples reached here.  /* #neg=11 */


% Clauses:

father(A, B, 0.15274385809367097) :- 
     childof(B, A), 
     male(B), 
     !. // Clause #1.

father(A, B, -0.0716609694856139) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.15274385809367097) :-  /* #pos=5 */ 
   childof(b, a),
   male(b),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.0716609694856139) :-  /* #neg=11 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)
%   male(b)

% Saving model in: data/toy_father/train/models/bRDNs/father.model.ckpt
% Time taken to learn 9 trees is 328 milliseconds.

%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.010851356473370124
Set score:0.0025
% Kept 5 of the 5 positive examples.
% Kept 10 of the 21 negative examples.
% Dataset size: 15
Computing probabilities
prob time:5 milliseconds
No hidden examples for : father
Time to build dataset: 5 milliseconds
%      addToQueueOfTreeStructuredLearningTasks (level=0; score=1,797693135e+308)
%         ILP node to extend: null
%      Insert tree-structured search node (@ level = 0 and with score = 1,797693135e+308) into the LAST position (#1) in the search queue.
Variance:0.00903934364718087
Set score:0.0022598359117952174

% Have these 8 positive seeds: 0 2 4 5 9 10 13 14

% target           = father(A, B)
%     Score = -Infinity (regressionFit = Infinity, penalties=2.2E-7) for clause:  father(_, _).  [covers 15,0/15,0 pos, 0,0/0,0 neg]
% Most-general root: father(_, _).  [covers 15,0/15,0 pos, 0,0/0,0 neg]  score = -Infinity
%     Score = -0,122380 (regressionFit = 0,122378, penalties=1.12E-6) for clause:  father(A, _) :- male(A).  [covers 9,0/15,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,122380): father(A, _) :- male(A).  [covers 9,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,087499 (regressionFit = 0,087498, penalties=1.12E-6) for clause:  father(_, A) :- male(A).  [covers 9,0/15,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,087499): father(_, A) :- male(A).  [covers 9,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,065877 (regressionFit = 0,065876, penalties=1.0200000000000002E-6) for clause:  father(A, B) :- childof(B, A).  [covers 7,0/15,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,065877): father(A, B) :- childof(B, A).  [covers 7,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,125066 (regressionFit = 0,125065, penalties=1.23E-6) for clause:  father(A, _) :- siblingof(A, _).  [covers 6,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,037307 (regressionFit = 0,037305, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(A).  [covers 4,0/15,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,037307): father(A, B) :- childof(B, A), male(A).  [covers 4,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,000450 (regressionFit = 0,000448, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
% Gleaner: New best node found (score = -0,000450): father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,100202 (regressionFit = 0,100200, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- childof(B, A), siblingof(A, _).  [covers 4,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,103594 (regressionFit = 0,103592, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(B), male(A).  [covers 7,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,000450 (regressionFit = 0,000448, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(B), childof(B, A).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,096430 (regressionFit = 0,096428, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- male(B), siblingof(A, _).  [covers 4,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,103594 (regressionFit = 0,103592, penalties=1.9200000000000003E-6) for clause:  father(A, B) :- male(A), male(B).  [covers 7,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,037307 (regressionFit = 0,037305, penalties=2.0200000000000006E-6) for clause:  father(A, B) :- male(A), childof(B, A).  [covers 4,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,128822 (regressionFit = 0,128819, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- male(A), siblingof(A, _).  [covers 4,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,130641 (regressionFit = 0,130639, penalties=2.2300000000000002E-6) for clause:  father(A, _) :- siblingof(A, _), male(A).  [covers 4,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,092286 (regressionFit = 0,092284, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), male(B).  [covers 4,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,125603 (regressionFit = 0,125601, penalties=2.1300000000000004E-6) for clause:  father(A, _) :- siblingof(A, B), male(B).  [covers 6,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,097298 (regressionFit = 0,097295, penalties=2.1300000000000004E-6) for clause:  father(A, B) :- siblingof(A, _), childof(B, A).  [covers 4,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,097297 (regressionFit = 0,097295, penalties=2.0300000000000005E-6) for clause:  father(A, B) :- siblingof(A, C), childof(B, C).  [covers 4,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,125067 (regressionFit = 0,125065, penalties=2.24E-6) for clause:  father(A, _) :- siblingof(A, _), siblingof(A, _).  [covers 6,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,125067 (regressionFit = 0,125065, penalties=2.0300000000000005E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, A).  [covers 6,0/15,0 pos, 0,0/0,0 neg]
%     Score = -0,125067 (regressionFit = 0,125065, penalties=2.1400000000000003E-6) for clause:  father(A, _) :- siblingof(A, B), siblingof(B, _).  [covers 6,0/15,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]

% The best node found: father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]

% Expanding node at Level 0 with score = 1,797693e+308.
% Will extend: father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
Comparing variance: 0.0 to score=0.0022598359117952174 #egs=5.0
Comparing variance: 4.481187751312343E-5 to score=0.0022598359117952174 #egs=10.0
%   Creating a TRUE-branch leaf because wgtedCountTrueBranchPos = 5,0 < 2.1 * minPosCov = 6,3
%   Creating a FALSE-branch leaf because good enough fit since score < 0.0022598359117952174

% Time for loop #1: 18 milliseconds.
% Internal node max length = 2
% Max tree depth in lits   = 3
% Max tree depth in nodes  = 3
% Max number of clauses    = 16

% On cycle #1, the best clause found is:
%      father(A, B) :- childof(B, A), male(B).  [covers 5,0/15,0 pos, 0,0/0,0 neg]
% This clause covers 5 positive examples, of which 5 are newly covered.
% It also covers 0 negative examples, of which 0 are newly covered.

% ******************************************

%  Have stopped ILP's outer loop because the tree-structured queue is empty.

% ******************************************

%%%%%  WILL-Produced Tree #10 @ 14:10:39 10/20/22.  %%%%%


% FOR father(A, B):
%   if ( childof(B, A), male(B) )
%   then return 0.13400703000801117;  // std dev = 0,000, 5,000 (wgt'ed) examples reached here.  /* #pos=5 */
%   else return -0.06734492746887692;  // std dev = 0,021, 10,000 (wgt'ed) examples reached here.  /* #neg=10 */


% Clauses:

father(A, B, 0.13400703000801117) :- 
     childof(B, A), 
     male(B), 
     !. // Clause #1.

father(A, B, -0.06734492746887692) :- !. // Clause #2.


% The flattened versions of these clauses:

flattened_father(a, b, 0.13400703000801117) :-  /* #pos=5 */ 
   childof(b, a),
   male(b),
   !. // Flattened version of clause #1.

flattened_father(underscore, underscore, -0.06734492746887692) :-  /* #neg=10 */ 
   !. // Flattened version of clause #2.


% The unique flattened literals:
%   childof(b, a)
%   male(b)

% Saving model in: data/toy_father/train/models/bRDNs/father.model.ckpt
% Saving model in: data/toy_father/train/models/bRDNs/father.model


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%  Final call for computing score for father.  %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

stepLength_tree1(1.0).
stepLength_tree2(1.0).
stepLength_tree3(1.0).
stepLength_tree4(1.0).
stepLength_tree5(1.0).
stepLength_tree6(1.0).
stepLength_tree7(1.0).
stepLength_tree8(1.0).
stepLength_tree9(1.0).
stepLength_tree10(1.0).

logPrior(-1.8).
father(A, B, Total) :- // A general accessor. 
   father(A, B, 1000000, Total), !.
father(A, B, Total) :- waitHere("This should not fail", father(A, B, Total)).

father(A, B, TreesToUse, Total) :- // A tree-limited accessor (e.g., for tuning the number of trees to use).
   logPrior(LogPrior),
   getScore_father_tree1(A, B, TreesToUse, Total1),
   getScore_father_tree2(A, B, TreesToUse, Total2),
   getScore_father_tree3(A, B, TreesToUse, Total3),
   getScore_father_tree4(A, B, TreesToUse, Total4),
   getScore_father_tree5(A, B, TreesToUse, Total5),
   getScore_father_tree6(A, B, TreesToUse, Total6),
   getScore_father_tree7(A, B, TreesToUse, Total7),
   getScore_father_tree8(A, B, TreesToUse, Total8),
   getScore_father_tree9(A, B, TreesToUse, Total9),
   getScore_father_tree10(A, B, TreesToUse, Total10),
   Total is LogPrior + Total1 + Total2 + Total3 + Total4 + Total5 + Total6 + Total7 + Total8 + Total9 + Total10,
   !.
father(A, B, TreesToUse, Total) :- waitHere("This should not fail", father(A, B, TreesToUse, Total)).

getScore_father_tree1(A, B, TreesToUse, 0.0) :- 1 > TreesToUse, !.
getScore_father_tree1(A, B, TreesToUse, Total1) :- father_tree1(A, B, Total), stepLength_tree1(StepLen), Total1 is Total * StepLen.

getScore_father_tree2(A, B, TreesToUse, 0.0) :- 2 > TreesToUse, !.
getScore_father_tree2(A, B, TreesToUse, Total2) :- father_tree2(A, B, Total), stepLength_tree2(StepLen), Total2 is Total * StepLen.

getScore_father_tree3(A, B, TreesToUse, 0.0) :- 3 > TreesToUse, !.
getScore_father_tree3(A, B, TreesToUse, Total3) :- father_tree3(A, B, Total), stepLength_tree3(StepLen), Total3 is Total * StepLen.

getScore_father_tree4(A, B, TreesToUse, 0.0) :- 4 > TreesToUse, !.
getScore_father_tree4(A, B, TreesToUse, Total4) :- father_tree4(A, B, Total), stepLength_tree4(StepLen), Total4 is Total * StepLen.

getScore_father_tree5(A, B, TreesToUse, 0.0) :- 5 > TreesToUse, !.
getScore_father_tree5(A, B, TreesToUse, Total5) :- father_tree5(A, B, Total), stepLength_tree5(StepLen), Total5 is Total * StepLen.

getScore_father_tree6(A, B, TreesToUse, 0.0) :- 6 > TreesToUse, !.
getScore_father_tree6(A, B, TreesToUse, Total6) :- father_tree6(A, B, Total), stepLength_tree6(StepLen), Total6 is Total * StepLen.

getScore_father_tree7(A, B, TreesToUse, 0.0) :- 7 > TreesToUse, !.
getScore_father_tree7(A, B, TreesToUse, Total7) :- father_tree7(A, B, Total), stepLength_tree7(StepLen), Total7 is Total * StepLen.

getScore_father_tree8(A, B, TreesToUse, 0.0) :- 8 > TreesToUse, !.
getScore_father_tree8(A, B, TreesToUse, Total8) :- father_tree8(A, B, Total), stepLength_tree8(StepLen), Total8 is Total * StepLen.

getScore_father_tree9(A, B, TreesToUse, 0.0) :- 9 > TreesToUse, !.
getScore_father_tree9(A, B, TreesToUse, Total9) :- father_tree9(A, B, Total), stepLength_tree9(StepLen), Total9 is Total * StepLen.

getScore_father_tree10(A, B, TreesToUse, 0.0) :- 10 > TreesToUse, !.
getScore_father_tree10(A, B, TreesToUse, Total10) :- father_tree10(A, B, Total), stepLength_tree10(StepLen), Total10 is Total * StepLen.

flattenedLiteralsInThisSetOfTrees(father, 2, [
   childof(b, a),
   male(b)]).
% Time taken to learn model for 'father': 365 milliseconds.
% Saving model in: data/toy_father/train/models/bRDNs/father.model
cached groundings hit: 0
Misses: 0

% Total learning time (10 trees): 377 milliseconds.

% Switching to VarIndicator = uppercase.

% Unset'ing VarIndicator.

Resetting the LazyGroundNthArgumentClauseIndex.

% Calling ILPouterLoop from createRegressionOuterLooper.

% getInputArgWithDefaultValue: args=[data/toy_father/test/test_pos.txt, data/toy_father/test/test_neg.txt, data/toy_father/test/test_bk.txt, data/toy_father/test/test_facts.txt]
%  for N=0: args[N]=data/toy_father/test/test_pos.txt

% getInputArgWithDefaultValue: args=[data/toy_father/test/test_pos.txt, data/toy_father/test/test_neg.txt, data/toy_father/test/test_bk.txt, data/toy_father/test/test_facts.txt]
%  for N=1: args[N]=data/toy_father/test/test_neg.txt

% getInputArgWithDefaultValue: args=[data/toy_father/test/test_pos.txt, data/toy_father/test/test_neg.txt, data/toy_father/test/test_bk.txt, data/toy_father/test/test_facts.txt]
%  for N=2: args[N]=data/toy_father/test/test_bk.txt

% getInputArgWithDefaultValue: args=[data/toy_father/test/test_pos.txt, data/toy_father/test/test_neg.txt, data/toy_father/test/test_bk.txt, data/toy_father/test/test_facts.txt]
%  for N=3: args[N]=data/toy_father/test/test_facts.txt

% Welcome to the WILL ILP/SRL systems.

% Reading background theory from dir: null

% Switching to VarIndicator = uppercase.

***** Warning: % Since this is the first setting of the notation for variables, will keep:
%   variableIndicator = uppercase *****

% [ LazyGroundClauseIndex ]  Building full index for mode/1 with 1 assertions.

%  Read the facts.
%  Have read 11 facts.
% Have read 3 examples from 'data/toy_father/test' [data/toy_father/test/test*].
% Have read 4 examples from 'data/toy_father/test' [data/toy_father/test/test*].

%  LearnOneClause initialized.

% The outer looper has been created.

% Initializing the ILP inner looper.

% NEW target:                 father(A, B)
%  targetPred:                father/2
%  targetArgTypes:            signature = [const, const], types = [+name, +name]
%  targets:                   [father(A, B)]
%  targetPredicates:          [father/2]
%  targetArgSpecs:            [[A[+name], B[+name]]]
%  variablesInTargets:        [[A, B]]

% Started collecting constants

% Collecting the types of constants.

% Looking at the training examples to see if any types of new constants can be inferred.
% Time to collect constants: 0 seconds

% Read 3 pos examples and 4 neg examples.
% Time to init learnOneClause: 0 seconds
% Old dirdata/toy_father/train/models/

% Have 3 'raw' positive examples and kept 3.
% Have 4 'raw' negative examples and kept 4.

% processing backup's for father
%  POS EX = 3
%  NEG EX = 4

% Memory usage by WILLSetup (just counts # targets?):
%  |backupPosExamples| = 1
%  |backupNegExamples| = 1
%  |predicatesAsFacts| = 0
%  |addedToFactBase|   = 0

% Getting bRDN's target predicates.
% Did not learn a model for 'father' this run.
%   loadModel (#0): data/toy_father/train/models/bRDNs/Trees/fatherTree0.tree
%   loadModel (#1): data/toy_father/train/models/bRDNs/Trees/fatherTree1.tree
%   loadModel (#2): data/toy_father/train/models/bRDNs/Trees/fatherTree2.tree
%   loadModel (#3): data/toy_father/train/models/bRDNs/Trees/fatherTree3.tree
%   loadModel (#4): data/toy_father/train/models/bRDNs/Trees/fatherTree4.tree
%   loadModel (#5): data/toy_father/train/models/bRDNs/Trees/fatherTree5.tree
%   loadModel (#6): data/toy_father/train/models/bRDNs/Trees/fatherTree6.tree
%   loadModel (#7): data/toy_father/train/models/bRDNs/Trees/fatherTree7.tree
%   loadModel (#8): data/toy_father/train/models/bRDNs/Trees/fatherTree8.tree
%   loadModel (#9): data/toy_father/train/models/bRDNs/Trees/fatherTree9.tree
%  Done loading 10 models.

% for father |lookupPos| = 3
% for father |lookupNeg| = 4
% getJointExamples: |pos| = 3, |neg| = 4

% Starting inference in bRDN.

% Subsampling the negative examples.
% Trees = 10
% [ LazyGroundClauseIndex ]  Building full index for childof/2 with 6 assertions.
% [ LazyGroundClauseIndex ]  Building full index for male/1 with 3 assertions.
 (Arithmetic) Mean Probability Assigned to Correct Output Class: 6,402/7,00 = 0,914581

 The weighted count of positive examples = 3,000 and the weighted count of negative examples = 4,000

printExamples: Writing out predictions (for Tuffy?) on 7 examples for 'father' to:
  data/toy_father/test/results_father.db
 and to:
  data/toy_father/test/query_father.db

% Computing Area Under Curves.
%Pos=3
%Neg=4
%LL:-0.38078705156403625
%LL:-0.6286301738788462
Best F1 = 1.0
% F1 = 1.0
% Threshold = 0.47043822129593255

%   AUC ROC   = 1,000000
%   AUC PR    = 1,000000
%   CLL	      = -0,089804
%   Precision = 1,000000 at threshold = 0,500
%   Recall    = 1,000000
%   F1        = 1,000000

% Total inference time (10 trees): 35 milliseconds.
]]></system-out>
  <system-err><![CDATA[]]></system-err>
</testsuite>
